syntax = "proto3";
option go_package="github.com/project-illium/ilxd/rpc/pb";

package pb;

import "transactions.proto";
import "blocks.proto";

service BlockchainService {
    // GetMempoolInfo returns the state of the current mempool
    rpc GetMempoolInfo(GetMempoolInfoRequest) returns (GetMempoolInfoResponse) {}

    // GetMempool returns all the transactions in the mempool
    rpc GetMempool(GetMempoolRequest) returns (GetMempoolResponse) {}

    // GetBlockchainInfo returns data about the blockchain including the most recent
    // block hash and height.
    rpc GetBlockchainInfo(GetBlockchainInfoRequest) returns (GetBlockchainInfoResponse) {}

    // GetBlockInfo returns a BlockHeader plus some extra metadata.
    rpc GetBlockInfo(GetBlockInfoRequest)returns (GetBlockInfoResponse) {}

    // GetBlock returns a BlockInfo metadata object plus the transactions either
    // as IDs or full transactions.
    rpc GetBlock(GetBlockRequest) returns (GetBlockResponse) {}

    // GetRawBlock returns the raw block in protobuf format
    rpc GetRawBlock(GetRawBlockRequest) returns (GetRawBlockResponse) {}

    // GetCompressedBlock returns a block that is stripped down to just the outputs.
    // It is the bare minimum information a client side wallet needs to compute its internal
    // state.
    rpc GetCompressedBlock(GetCompressedBlockRequest) returns (GetCompressedBlockResponse) {}

    // GetHeaders returns a batch of headers according to the request parameters.
    rpc GetHeaders(GetHeadersRequest) returns (GetHeadersResponse) {}

    // GetCompressedBlocks returns a batch of CompressedBlocks according to the request parameters.
    rpc GetCompressedBlocks(GetCompressedBlocksRequest) returns (GetCompressedBlocksResponse) {}

    // GetTransaction returns the transaction for the given transaction ID.
    //
    // **Requires TxIndex**
    // **Input/Output metadata requires AddrIndex**
    rpc GetTransaction(GetTransactionRequest) returns (GetTransactionResponse) {}

    // GetAddressTransactions returns a list of transactions for the given address
    // Note: only public address are indexed
    //
    // **Requires AddrIndex**
    rpc GetAddressTransactions(GetAddressTransactionsRequest) returns (GetAddressTransactionsResponse) {}

    // GetMerkleProof returns a Merkle (SPV) proof for a specific transaction
    // in the provided block.
    //
    // **Requires TxIndex**
    rpc GetMerkleProof(GetMerkleProofRequest) returns (GetMerkleProofResponse) {}

    // GetValidator returns all the information about the given validator including number
    // of staked coins.
    rpc GetValidator(GetValidatorRequest) returns (GetValidatorResponse) {}

    // GetValidatorSetInfo returns information about the validator set.
    rpc GetValidatorSetInfo(GetValidatorSetInfoRequest) returns (GetValidatorSetInfoResponse) {}

    // GetValidatorSet returns all the validators in the current validator set.
    rpc GetValidatorSet(GetValidatorSetRequest) returns (GetValidatorSetResponse) {}

    // GetValidatorCoinbases returns a list of coinbase txids for the validator.
    //
    // **Requires AddrIndex**
    rpc GetValidatorCoinbases(GetValidatorCoinbasesRequest) returns (GetValidatorCoinbasesResponse) {}

    // GetAccumulatorCheckpoint returns the accumulator at the requested height.
    // If there is no checkpoint at that height, the *prior* checkpoint found in the
    // chain will be returned. If there is no prior checkpoint (as is prior to the first)
    // an error will be returned.
    rpc GetAccumulatorCheckpoint(GetAccumulatorCheckpointRequest) returns (GetAccumulatorCheckpointResponse) {}

    // SubmitTransaction validates a transaction and submits it to the network. An error will be returned
    // if it fails validation.
    rpc SubmitTransaction(SubmitTransactionRequest) returns (SubmitTransactionResponse) {}

    // SubscribeBlocks returns a stream of notifications when new blocks are finalized and
    // connected to the chain.
    rpc SubscribeBlocks(SubscribeBlocksRequest) returns (stream BlockNotification) {}

    // SubscribeCompressedBlocks returns a stream of CompressedBlock notifications when new
    // blocks are finalized and connected to the chain.
    rpc SubscribeCompressedBlocks(SubscribeCompressedBlocksRequest) returns (stream CompressedBlockNotification) {}
}

service WalletServerService {
    // RegisterViewKey registers a new view key with the server. The server will use this key when
    // attempting to decrypt each output. If outputs decrypt, they will be indexed so the client
    // can fetch them later.
    //
    // To free up resources keys will automatically unregister if the wallet has not connected
    // in some time.
    rpc RegisterViewKey(RegisterViewKeyRequest) returns (RegisterViewKeyResponse) {}

    // SubscribeTransactions subscribes to a stream of TransactionsNotifications that match to the
    // provided view key.
    rpc SubscribeTransactions(SubscribeTransactionsRequest) returns (stream TransactionNotification) {}

    // GetWalletTransactions returns a list of transactions for the provided view key.
    rpc GetWalletTransactions(GetWalletTransactionsRequest) returns (GetWalletTransactionsResponse) {}

    // GetTxoProof returns the merkle inclusion proof for the given commitment. This information is needed
    // by the client to create the zero knowledge proof needed to spend the transaction.
    rpc GetTxoProof(GetTxoProofRequest) returns (GetTxoProofResponse) {}
}

service ProverService {
    // Prove creates the proof for the transaction and returns the transaction
    // with the proof attached. The transaction is *not* submitted to the network.
    //
    // The transaction is validated against the mempool and will return an error
    // if it is an otherwise invalid transaction.
    rpc Prove(ProveRequest) returns (ProveResponse) {}

    // ProveAndSubmit creates the proof for the transaction and then submits it to
    // the network. And error is returned if it fails mempool submission.
    rpc ProveAndSubmit(ProveAndSubmitRequest) returns (ProveAndSubmitResponse) {}
}

service WalletService {
    // GetBalance returns the combined balance of all addresses in the wallet
    rpc GetBalance(GetBalanceRequest) returns (GetBalanceResponse) {}

    // GetWalletSeed returns the mnemonic seed for the wallet. If the wallet
    // seed has been deleted via the `DeletePrivateKeys` RPC an error will be
    // returned.
    //
    // **Requires wallet to be unlocked**
    rpc GetWalletSeed(GetWalletSeedRequest) returns (GetWalletSeedResponse) {}

    // GetAddress returns the most recent address of the wallet.
    rpc GetAddress(GetAddressRequest) returns (GetAddressResponse) {}

    // GetTimelockedAddress returns a timelocked address that cannot be spent
    // from until the given timelock has passed.
    //
    // The private key used for this address is the same as the wallet's most
    // recent spend key used in a basic address. This implies the key can be
    // derived from seed, however the wallet will not detect incoming payments
    // to this address unless the timelock is included in the utxo's state field.
    rpc GetTimelockedAddress(GetTimelockedAddressRequest) returns (GetTimelockedAddressResponse) {}

    // GetPublicAddress returns a public address for the wallet. This address type
    // requires that the private output data that is normally encrypted with the
    // recipient's view key be put in the transaction in the clear.
    //
    // The private key used for this address is the same as the wallet's most
    // recent spend key used in a basic address. This implies the key can be
    // derived from seed.
    rpc GetPublicAddress(GetPublicAddressRequest) returns (GetPublicAddressResponse) {}

    // GetAddresses returns all the addresses create by the wallet.
    rpc GetAddresses(GetAddressesRequest) returns (GetAddressesResponse) {}

    // GetAddressInfo returns additional metadata about an address.
    rpc GetAddressInfo(GetAddressInfoRequest) returns (GetAddressInfoResponse) {}

    // GetNewAddress generates a new address and returns it. Both a new spend key
    // and view key will be derived from the mnemonic seed.
    rpc GetNewAddress(GetNewAddressRequest) returns (GetNewAddressResponse) {}

    // GetTransactions returns the list of transactions for the wallet
    rpc GetTransactions(GetTransactionsRequest) returns (GetTransactionsResponse) {}

    // GetUtxos returns a list of the wallet's current unspent transaction outputs (UTXOs)
    rpc GetUtxos(GetUtxosRequest) returns (GetUtxosResponse) {}

    // GetPrivateKey returns the serialized spend and view keys for the given address
    //
    // **Requires wallet to be unlocked**
    rpc GetPrivateKey(GetPrivateKeyRequest) returns (GetPrivateKeyResponse) {}

    // ImportAddress imports a watch address into the wallet.
    rpc ImportAddress(ImportAddressRequest) returns (ImportAddressResponse) {}

    // CreateMultisigSpendKeypair generates a spend keypair for use in a multisig address
    rpc CreateMultisigSpendKeypair(CreateMultisigSpendKeypairRequest) returns (CreateMultisigSpendKeypairResponse) {}

    // CreateMultisigViewKeypair generates a view keypair for use in a multisig address
    rpc CreateMultisigViewKeypair(CreateMultisigViewKeypairRequest) returns (CreateMultisigViewKeypairResponse) {}

    // CreateMultisigAddress generates a new multisig address using the provided public keys
    //
    // Note this address is *not* imported. You will need to call `ImportAddress` if you want to watch
    // it.
    rpc CreateMultisigAddress(CreateMultisigAddressRequest) returns (CreateMultisigAddressResponse) {}

    // CreateMultiSignature generates and returns a signature for use when proving a multisig transaction
    rpc CreateMultiSignature(CreateMultiSignatureRequest) returns (CreateMultiSignatureResponse) {}

    // ProveMultisig creates a proof for a transaction with a multisig input
    rpc ProveMultisig(ProveMultisigRequest) returns (ProveMultisigResponse) {}

    // WalletLock encrypts the wallet's private keys
    rpc WalletLock(WalletLockRequest) returns (WalletLockResponse) {}

    // WalletUnlock decrypts the wallet seed and holds it in memory for the specified period of time
    rpc WalletUnlock(WalletUnlockRequest) returns (WalletUnlockResponse) {}

    // SetWalletPassphrase encrypts the wallet for the first time
    rpc SetWalletPassphrase(SetWalletPassphraseRequest) returns (SetWalletPassphraseResponse) {}

    // ChangeWalletPassphrase changes the passphrase used to encrypt the wallet private keys
    rpc ChangeWalletPassphrase(ChangeWalletPassphraseRequest) returns (ChangeWalletPassphraseResponse) {}

    // DeletePrivateKeys deletes the wallet's private keys and seed from disk essentially turning the wallet
    // into a watch-only wallet. It will still record incoming transactions but cannot spend them.
    //
    // **Requires wallet to be unlocked**
    rpc DeletePrivateKeys(DeletePrivateKeysRequest) returns (DeletePrivateKeysResponse) {}

    // CreateRawTransaction creates a new, unsigned (unproven) transaction using the given parameters
    rpc CreateRawTransaction(CreateRawTransactionRequest) returns (CreateRawTransactionResponse) {}

    // CreateRawStakeTransaction creates a new, unsigned (unproven) stake transaction using the given parameters
    rpc CreateRawStakeTransaction(CreateRawStakeTransactionRequest) returns (CreateRawStakeTransactionResponse) {}

    // ProveRawTransaction creates the zk-proof for the transaction. Assuming there are no errors, this
    // transaction should be ready for broadcast.
    rpc ProveRawTransaction(ProveRawTransactionRequest) returns (ProveRawTransactionResponse) {}

    // Stake stakes the selected wallet UTXOs and turns the node into a validator
    //
    // **Requires wallet to be unlocked**
    rpc Stake(StakeRequest) returns (StakeResponse) {}

    // SetAutoStakeRewards make it such that any validator rewards that are earned are automatically staked
    //
    // **Requires wallet to be unlocked**
    rpc SetAutoStakeRewards(SetAutoStakeRewardsRequest) returns (SetAutoStakeRewardsResponse) {}

    // Spend sends coins from the wallet according to the provided parameters
    //
    // **Requires wallet to be unlocked**
    rpc Spend(SpendRequest) returns (SpendResponse) {}

    // TimelockCoins moves coins into a timelocked address using the requested timelock.
    // The internal wallet will be able to spend the coins after the timelock expires and
    // the transaction will be recoverable if the wallet is restored from seed.
    //
    // This RPC primarily exists to lock coins for staking purposes.
    //
    // **Requires wallet to be unlocked**
    rpc TimelockCoins(TimelockCoinsRequest) returns (TimelockCoinsResponse) {}

    // SweepWallet sweeps all the coins from this wallet to the provided address.
    // This RPC is provided so that you don't have to try to guess the correct fee
    // to take the wallet's balance down to zero. Here the fee will be subtracted
    // from the total funds.
    //
    // **Requires wallet to be unlocked**
    rpc SweepWallet(SweepWalletRequest) returns (SweepWalletResponse) {}

    // SubscribeWalletTransactions subscribes to a stream of WalletTransactionsNotifications that return
    // whenever a transaction belonging to the wallet finalizes.
    rpc SubscribeWalletTransactions(SubscribeWalletTransactionsRequest) returns (stream WalletTransactionNotification) {}

    // SubscribeWalletSyncNotifications streams notifications about the status of the wallet sync.
    rpc SubscribeWalletSyncNotifications(SubscribeWalletSyncNotificationsRequest) returns (stream WalletSyncNotification) {}
}

service NodeService {
    // GetHostInfo returns info about the libp2p host
    rpc GetHostInfo(GetHostInfoRequest) returns (GetHostInfoResponse) {}

    // GetNetworkKey returns the node's network private key
    rpc GetNetworkKey(GetNetworkKeyRequest) returns (GetNetworkKeyResponse) {}

    // GetPeers returns a list of peers that this node is connected to
    rpc GetPeers(GetPeersRequest) returns (GetPeersResponse) {}

    // GetPeerInfo returns a list of peers that this node is connected to
    rpc GetPeerInfo(GetPeerInfoRequest) returns (GetPeerInfoResponse) {}

    // AddPeer attempts to connect to the provided peer
    rpc AddPeer(AddPeerRequest) returns (AddPeerResponse) {}

    // BlockPeer blocks the given peer for the provided time period
    rpc BlockPeer(BlockPeerRequest) returns (BlockPeerResponse) {}

    // UnblockPeer removes a peer from the block list
    rpc UnblockPeer(UnblockPeerRequest) returns (UnblockPeerResponse) {}

    // SetLogLevel changes the logging level of the node
    rpc SetLogLevel(SetLogLevelRequest) returns (SetLogLevelResponse) {}

    // GetMinFeePerKilobyte returns the node's current minimum transaction fee needed to relay
    // transactions and admit them into the mempool. Validators will also set their initial preference
    // for blocks containing transactions with fees below this threshold to not-preferred.
    rpc GetMinFeePerKilobyte(GetMinFeePerKilobyteRequest) returns (GetMinFeePerKilobyteResponse) {}

    // SetMinFeePerKilobyte sets the node's fee policy
    rpc SetMinFeePerKilobyte(SetMinFeePerKilobyteRequest) returns (SetMinFeePerKilobyteResponse) {}

    // GetMinStake returns the node's current minimum stake policy. Stake transactions staking less than
    // this amount will not be admitted into the mempool and will not be relayed. Validators will also
    // set their initial preference for blocks containing stake transactions below this threshold to
    // not-preferred.
    rpc GetMinStake(GetMinStakeRequest) returns (GetMinStakeResponse) {}

    // SetMinStake sets the node's minimum stake policy
    rpc SetMinStake(SetMinStakeRequest) returns (SetMinStakeResponse) {}

    // GetBlockSizeSoftLimit returns the node's current blocksize soft limit. Validators will also
    // set their initial preference for blocks over this size to not-preferred.
    rpc GetBlockSizeSoftLimit(GetBlockSizeSoftLimitRequest) returns (GetBlockSizeSoftLimitResponse) {}

    // SetBlockSizeSoftLimit sets the node's blocksize soft limit policy.
    rpc SetBlockSizeSoftLimit(SetBlockSizeSoftLimitRequest) returns (SetBlockSizeSoftLimitResponse) {}

    // GetTreasuryWhitelist returns the current treasury whitelist for the node. Blocks containing
    // TreasuryTransactions not found in this list will have their initial preference set to not-preferred.
    rpc GetTreasuryWhitelist(GetTreasuryWhitelistRequest) returns (GetTreasuryWhitelistResponse) {}

    // UpdateTreasuryWhitelist adds or removes a transaction to from the treasury whitelist.
    // This update is committed to the datastore and will persist between sessions.
    rpc UpdateTreasuryWhitelist(UpdateTreasuryWhitelistRequest) returns (UpdateTreasuryWhitelistResponse) {}

    // ReconsiderBlock tries to reprocess the given block
    rpc ReconsiderBlock(ReconsiderBlockRequest) returns (ReconsiderBlockResponse) {}

    // RecomputeChainState deletes the accumulator, validator set, and nullifier set and rebuilds them by
    // loading and re-processing all blocks from genesis.
    rpc RecomputeChainState(RecomputeChainStateRequest) returns (RecomputeChainStateResponse) {}
}

// RPC MESSAGES

// BlockchainService
message GetMempoolInfoRequest{}
message GetMempoolInfoResponse {
    // The count of transactions in the mempool
    uint32 size  = 1;
    // The size in bytes of all transactions in the mempool
    uint32 bytes = 2;
}

message GetMempoolRequest {
    // When `full_transactions` is true, full transaction data is provided
    // instead of just transaction hashes. Default is false.
    bool full_transactions = 1;
}
message GetMempoolResponse {
    // List of unconfirmed transactions.
    repeated TransactionData transaction_data = 1;
}

message GetBlockchainInfoRequest {}
message GetBlockchainInfoResponse {
    // Illium network types
    enum Network {
        // Live public network with monetary value
        MAINNET  = 0;
        // An isolated environment for automated testing
        REGTEST  = 1;
        // A public environment where monetary value is agreed to be zero,
        // and some checks for transaction conformity are disabled.
        TESTNET  = 2;
        // Alpha testnet
        ALPHANET = 3;
    }

    // Which network the node is operating on
    Network network          = 1;
    // The current number of blocks in the chain
    uint32 best_height        = 2;
    // The hash of the best (tip) block in the chain
    bytes best_block_ID      = 3;
    // The timestamp of the best block
    int64 block_time         = 4;
    // When `tx_index` is true, the node has full transaction index enabled
    bool tx_index            = 5;
    // The total number of coins in circulation in nanoillium
    uint64 circulating_supply = 6;
    // The total number of coins staked in nanoillium
    uint64 total_staked      = 7;
    // The balance of the treasury in nanoillium
    uint64 treasury_balance  = 8;
    // The total size of the database on disk
    uint64 blockchain_size   = 9;
    // The current epoch number (also total number of epochs)
    uint32 epoch             = 10;
}

message GetBlockInfoRequest {
    oneof id_or_height {
        // The block hash as a byte array
        bytes block_ID = 1;
        // The block number
        uint32 height   = 2;
    }
}
message GetBlockInfoResponse {
    // Marshaled block header data, as well as metadata
    BlockInfo info = 1;
}

message GetBlockRequest {
    oneof id_or_height {
        // The block hash as a byte array
        bytes block_ID = 1;
        // The block number
        uint32 height   = 2;
    }

    // Default is false, only the transaction IDs are included for
    // a marshaled block.
    bool full_transactions = 3;
}
message GetBlockResponse {
    // The BlockInfo (including header data) for the block
    BlockInfo block_info                  = 1;
    // The blocks transactions (if requested).
    //
    // The transactions will either be returned in for or just the txids depending
    // on the request.
    repeated TransactionData transactions = 2;
}

message GetRawBlockRequest {
    oneof id_or_height {
        // The block hash as a byte array
        bytes block_ID = 1;
        // The block number
        uint32 height   = 2;
    }
}
message GetRawBlockResponse {
    // The full block response
    Block block = 1;
}

message GetCompressedBlockRequest {
    oneof id_or_height {
        // The block hash as a byte array
        bytes block_ID = 1;
        // The block number
        uint32 height   = 2;
    }
}
message GetCompressedBlockResponse {
    // The compressed block contains only transaction outputs
    CompressedBlock block = 1;
}

message GetHeadersRequest {
    // The height to start receiving headers
    uint32 start_height = 1;
    // The last header height to return. Note that a maximum of 2000
    // blocks will be returned per request. If end_height is > start_height + 1999
    // then end_height will be set set to start_height + 1999 and 2000 headers
    // will be returned. If end_height is past the tip of the chain the headers
    // will be returned up to the tip.
    //
    // If end_height is less than start_height 2000 headers will be returned.
    uint32 end_height   = 2;
}
message GetHeadersResponse {
    repeated BlockHeader headers = 1;
}

message GetCompressedBlocksRequest {
    // The height to start receiving headers
    uint32 start_height = 1;
    // The last block height to return. Note that a maximum of 2000 blocks will be returned
    // per request. If end_height is > start_height + 1999 then end_height will be set set
    // to start_height + 1999 and 2000 compressed blocks will be returned. If end_height is
    // past the tip of the chain the compressed blocks will be returned up to the tip.
    //
    // If end_height is less than start_height 2000 blocks will be returned.
    uint32 end_height   = 2;
}
message GetCompressedBlocksResponse {
    // The compressed block response
    repeated CompressedBlock blocks = 1;
}

message GetTransactionRequest {
    // A transaction hash
    bytes transaction_ID = 1;
}
message GetTransactionResponse {
    // The transaction response
    Transaction tx              = 1;
    // The ID of the containing block
    bytes block_ID              = 2;
    // The height of the containing block
    uint32 height               = 3;
    // The input and output metadata will
    // only only be non-nil if the address
    // index is enabled.
    //
    // Further it will only metadata for public
    // inputs or outputs will be included otherwise
    // it will be `unknown`.
    repeated IOMetadata inputs  = 4;
    repeated IOMetadata outputs = 5;
}

message GetAddressTransactionsRequest {
    // The address to get transactions for
    string address = 1;
    // The number of transactions to skip, starting with the oldest first.
    uint32 nb_skip = 2;
    // Specify the number of transactions to fetch.
    uint32 nb_fetch = 3;
}
message GetAddressTransactionsResponse {
    // The list of transactions
    repeated TransactionWithMetadata txs = 1;

    message TransactionWithMetadata {
        // The transaction response
        Transaction tx              = 1;
        // The ID of the containing block
        bytes block_ID              = 2;
        // The height of the containing block
        uint32 height               = 3;
        // Metadata will only metadata for public
        // inputs or outputs will be included otherwise
        // it will be `unknown`.
        repeated IOMetadata inputs  = 4;
        repeated IOMetadata outputs = 5;
    }
}

message GetMerkleProofRequest {
    // A transaction hash
    bytes transaction_ID = 1;
}
message GetMerkleProofResponse {
    // Block header information for the corresponding transaction
    BlockInfo block       = 1;
    // Is the proof hashes linking the tx to the root
    repeated bytes hashes  = 2;
    // The least significant bit in flags corresponds to the last hash in `hashes`. The second least
    // significant to the second to last hash, and so on. The bit signifies whether the hash should be
    // prepended (0) or appended (1) when hashing each level in the tree.
    uint32 flags           = 3;
}

message GetValidatorRequest {
    // A serialized validator ID
    bytes validator_ID = 1;
}
message GetValidatorResponse {
    // The validator response
    Validator validator = 1;
}

message GetValidatorCoinbasesRequest {
    // A serialized validator ID
    bytes validator_ID = 1;
}
message GetValidatorCoinbasesResponse {
    // Coinbase transactions
    repeated bytes txids = 1;
}

message GetValidatorSetInfoRequest{}
message GetValidatorSetInfoResponse{
    // The total number of coins staked on the network in nanoillium
    uint64 total_staked   = 1;
    // The total stake weighted by time locks in nanoillium
    uint64 stake_weight   = 2;
    // The total number of validators on the network
    uint32 num_validators = 3;
}

message GetValidatorSetRequest{}
message GetValidatorSetResponse{
    // The full list of validators on the network
    repeated Validator validators = 1;
}

message GetAccumulatorCheckpointRequest{
    oneof height_or_timestamp {
        // The height of the accumulator checkpoint to return.
        // If there is no checkpoint at that height, the *prior*
        // checkpoint found in the chain will be returned.
        //
        // An error will be returned if there is no checkpoint before
        // the provided height.
        uint32 height   = 1;
        // The timestamp of the accumulator checkpoint to return.
        // If there is no checkpoint at that timestamp, the *prior*
        // checkpoint found in the chain will be returned.
        //
        // An error will be returned if there is no checkpoint before
        // the provided timestamp.
        int64 timestamp = 2;
    }

}
message GetAccumulatorCheckpointResponse{
    // The height of the checkpoint
    uint32 height              = 1;
    // The number of entries in the accumulator at this checkpoint
    uint64 num_entries         = 2;
    // The accumulator hashes
    repeated bytes accumulator = 3;
}

message SubmitTransactionRequest {
    // The transaction to submit to the network
    Transaction transaction = 1;
}
message SubmitTransactionResponse {
    // The transaction ID of the transaction.
    //
    // If submission was unsuccessful and error will be returned.
    bytes transaction_ID = 1;
}

message SubscribeBlocksRequest {
    // When full_block is true, a complete marshaled block is sent.
    // Default is false, block metadata is sent. See `BlockInfo`.
    bool full_block        = 1;
    // When full_transactions is true, provide full transaction info
    // for a marshaled block.
    //
    // Default is false, only the transaction IDs are included for
    // a marshaled block.
    bool full_transactions = 2;
}

message SubscribeCompressedBlocksRequest {}

// WalletServerService
message RegisterViewKeyRequest {
    // A view key to register with the server.
    bytes view_key                  = 1;
    // The locking script associated with the address belonging
    // to the view key serialized as <scriptCommitment><lockingParams...>
    //
    // The server needs this in order to compute the nullifier and detect
    // spend transactions.
    bytes serializedLockingScript = 2;
    // The date the address was created. The server will scan historical blocks
    // for matching transactions from the birthday forward. Please don't use an
    // earlier birthday than needed as it puts more stress on the server.
    //
    // A zero value will not trigger a rescan.
    int64 birthday                  = 3;
}
message RegisterViewKeyResponse {}

message SubscribeTransactionsRequest {
    // A list of view keys to subscribe to
    repeated bytes view_keys   = 1;
}

message GetWalletTransactionsRequest{
    // The view key to query transactions
    bytes view_key = 1;
    // The number of transactions to skip, starting with the oldest first.
    uint32 nb_skip = 2;
    // Specify the number of transactions to fetch.
    uint32 nb_fetch = 3;


    oneof start_block {
        // Recommended. Only get transactions after (or within) a
        // starting block identified by hash.
        bytes block_ID = 4;
        // Recommended. Only get transactions after (or within) a
        // starting block identified by block number.
        uint32 height = 5;
    }
}
message GetWalletTransactionsResponse {
    // The height of the chain as of this query
    uint32 chain_height               = 1;
    // A list of transactions as the response
    repeated Transaction transactions = 2;
}

message GetTxoProofRequest {
    // One or more commitments to fetch the txo proof for.
    // Since transactions only contain one txo_root you
    // should request the commitment for each input in your
    // transaction as a batch so the returned proofs all share
    // the same txo_root. Otherwise you may get different roots
    // if you request them separately.
    repeated bytes commitments = 1;
}
message GetTxoProofResponse {
    // The proof responses
    repeated TxoProof proofs = 1;
}

// ProverService
message ProveRequest {
    // The full transaction with the proof set to nil
    Transaction transaction = 1;
    // The private (hidden) data for each input
    repeated PrivateInput inputs   = 2;
    // The private (hidden) data for each output
    repeated PrivateOutput outputs = 3;
}
message ProveResponse {
    // The returned transaction with the proof attached
    Transaction transaction = 1;
}

message ProveAndSubmitRequest {
    // The full transaction with the proof set to nil
    Transaction transaction = 1;
    // The private (hidden) data for each input
    repeated PrivateInput inputs   = 2;
    // The private (hidden) data for each output
    repeated PrivateOutput outputs = 3;
}
message ProveAndSubmitResponse {
    // The transaction ID of the transaction.
    //
    // If submission was unsuccessful and error will be returned.
    bytes transaction_ID = 1;
}

// WalletService
message GetBalanceRequest {}
message GetBalanceResponse {
    // Balance response in nanoillium
    uint64 balance = 1;
}

message GetWalletSeedRequest {}
message GetWalletSeedResponse {
    // The wallet's mnemonic seed
    string mnemonic_seed = 1;
}

message GetAddressRequest {}
message GetAddressResponse {
    // The most recent wallet address
    string address = 1;
}

message GetTimelockedAddressRequest {
    // The unix timestamp (in seconds) to lock the coins until
    int64 lock_until = 1;
}
message GetTimelockedAddressResponse {
    // The resulting timelocked address
    string address = 1;
}

message GetPublicAddressRequest {}
message GetPublicAddressResponse {
    // A public address built from the
    // most recent spend key in the wallet.
    string address = 1;
}

message GetAddressesRequest {}
message GetAddressesResponse {
    // All wallet addresses
    repeated string addresses = 1;
}

message GetAddressInfoRequest {
    // The address to get info for
    string address = 1;
}
message GetAddressInfoResponse {
    // The address to import
    string address          = 1;
    // This is the serialized locking script
    // <scriptCommitment><lockingParams>
    bytes lockingScript   = 2;
    //  The private view key for the address
    bytes viewPrivateKey     = 3;
    // Is this address watch only
    bool watchOnly          = 4;
}

message GetNewAddressRequest {}
message GetNewAddressResponse {
    // A fresh address generated by the wallet
    string address = 1;
}
message GetTransactionsRequest {
    // The number of transactions to skip, starting with the oldest first.
    uint32 nb_skip  = 1;
    // Specify the number of transactions to fetch.
    uint32 nb_fetch = 2;
}
message GetTransactionsResponse {
    // All transactions in the wallet
    repeated WalletTransaction txs = 1;
}

message GetUtxosRequest {}
message GetUtxosResponse {
    // The full list of utxos in the wallet
    repeated Utxo utxos = 1;
}

message GetPrivateKeyRequest {
    // The address to fetch private keys for
    string address = 1;
}
message GetPrivateKeyResponse {
    bytes serialized_keys = 2;
}

message ImportAddressRequest {
    // The address to import
    string address          = 1;
    // The address contains a scriptHash. We also
    // need what's behind the hash in order to
    // import an address and detect spends.
    //
    // This is the serialized locking script
    // <scriptCommitment><lockingParams>
    bytes lockingScript   = 2;
    // The view private key needed to decrypt and
    // detect transactions.
    bytes viewPrivateKey    = 3;
    // Should the wallet rescan the blockchain looking for
    // transactions for this address.
    bool rescan             = 4;
    // If so what height should it start the rescan.
    uint32 rescanFromHeight = 5;
}
message ImportAddressResponse {}

message CreateMultisigSpendKeypairRequest{}
message CreateMultisigSpendKeypairResponse{
    // A private key response
    bytes privkey = 1;
    // The corresponding public key
    bytes pubkey = 2;
}

message CreateMultisigViewKeypairRequest{}
message CreateMultisigViewKeypairResponse{
    // A private key response
    bytes privkey = 1;
    // The corresponding public key
    bytes pubkey = 2;
}

message CreateMultisigAddressRequest {
    // A list of public keys to use for the multisig address
    repeated bytes pubkeys = 1;
    // The number of keys required to sign the tranaction to
    // release the funds.
    uint32 threshold       = 2;
    // A view key to use with the address
    bytes view_pubkey      = 3;
}
message CreateMultisigAddressResponse {
    // Multisig address response
    string address = 1;
}

message CreateMultiSignatureRequest {
    oneof tx_or_sighash {
        // Either provide the transaction so the sighash can be computed
        Transaction tx = 1;
        // Or just provide the sighash itself
        bytes sighash  = 2;
    }

    // A private key to sign with
    bytes private_key = 3;
}
message CreateMultiSignatureResponse {
    // A signature covering the sighash
    bytes signature = 1;
}

message ProveMultisigRequest {
    // A transaction to prove. This RPC requires there to be only one
    // input and that the input be a multisig script.
    RawTransaction raw_tx   = 1;

    // A list of signatures. Each one must cover the transaction's sighash.
    repeated bytes sigs = 2;
}
message ProveMultisigResponse {
    // A full transaction with the proof attached
    Transaction proved_tx = 1;
}

message WalletLockRequest {}
message WalletLockResponse {}

message WalletUnlockRequest {
    // The wallet passphrase used to decrypt
    string passphrase = 1;
    // The duration (in seconds) to leave the wallet decrypted for.
    // It will automatically be re-encrypted after the duration passes.
    uint32 duration = 2;
}
message WalletUnlockResponse {}

message SetWalletPassphraseRequest {
    // Wallet passphrase
    string passphrase = 1;
}
message SetWalletPassphraseResponse{}

message ChangeWalletPassphraseRequest {
    // Current passphrase
    string current_passphrase = 1;
    // Passphrase to change it to
    string new_passphrase     = 2;
}
message ChangeWalletPassphraseResponse {}

message DeletePrivateKeysRequest {}
message DeletePrivateKeysResponse {}

message CreateRawTransactionRequest {
    // A list of either utxo commitments or private inputs
    repeated Input inputs     = 1;
    // A list of outputs to send coins to
    repeated Output outputs   = 2;
    // A bool to control whether the wallet will automatically append a
    // change output and send the remainder of the coins (minus a fee)
    // to the change output.
    bool append_change_output = 3;
    // If append_change_output is true you can specify the fee amount to use in nanoillium.
    // If zero the wallet will use its internal fee policy.
    uint64 fee_per_kilobyte   = 4;

    message Input {
        oneof commitment_or_private_input {
            // This is a utxo commitment known to the wallet
            bytes commitment = 1;
            // If trying to create a transaction spending a utxo that the
            // wallet does not know about you must provide the full private
            // input data.
            PrivateInput input = 2;
        }
    }

    message Output {
        // Address to send coins to
        string address = 1;
        // The amount to send in nanoillium
        uint64 amount  = 2;
        // An optional state field
        bytes state    = 3;
    }
}
message CreateRawTransactionResponse {
    // Raw transaction response
    RawTransaction raw_tx = 1;
}

message CreateRawStakeTransactionRequest {
    // A list of either utxo commitments or private inputs
    Input input = 1;

    message Input {
        oneof commitment_or_private_input {
            // This is a utxo commitment known to the wallet
            bytes commitment = 1;
            // If trying to create a transaction spending a utxo that the
            // wallet does not know about you must provide the full private
            // input data.
            PrivateInput input = 2;
        }
    }
}
message CreateRawStakeTransactionResponse {
    // Raw transaction response
    RawTransaction raw_tx = 1;
}

message ProveRawTransactionRequest {
    // The raw transaction to prove
    RawTransaction raw_tx = 1;
}
message ProveRawTransactionResponse {
    // A full transaction with the proof attached
    Transaction proved_tx = 1;
}

message StakeRequest {
    // The utxos to stake identified by their commitment hashes
    repeated bytes commitments = 1;
}
message StakeResponse {}

message SetAutoStakeRewardsRequest {
    // Whether to turn on or off autostaking
    bool autostake = 1;
}
message SetAutoStakeRewardsResponse {}

message SpendRequest {
    // Address to send funds to
    string to_address                = 1;
    // Amount to send in nanoillium
    uint64 amount                    = 2;
    // The fee to use for the transaction in nanoillium.
    // If zero the wallet will use its internal fee policy.
    uint64 fee_per_kilobyte          = 3;
    // An optional list of input commitments to spend. If this
    // is empty the wallet will select its own inputs.
    //
    // Note that staked commitments will not be selected by
    // the wallet. You will need to list staked commitments
    // here if you wish to spend them.
    repeated bytes input_commitments = 4;
}
message SpendResponse {
    // The transaction ID of the transaction.
    //
    // If submission was unsuccessful and error will be returned.
    bytes transaction_ID = 1;
}

message TimelockCoinsRequest {
    // Amount of coins to lock in nanoillium
    uint64 amount                    = 1;
    // The unix time (in seconds) to lock the coins until
    int64 lock_until                 = 2;
    // The fee to use for the transaction in nanoillium.
    // If zero the wallet will use its internal fee policy.
    uint64 fee_per_kilobyte          = 3;
    // An optional list of input commitments to spend. If this
    // is empty the wallet will select its own inputs.
    //
    // Note that staked commitments will not be selected by
    // the wallet. You will need to list staked commitments
    // here if you wish to spend them.
    repeated bytes input_commitments = 4;
}
message TimelockCoinsResponse {
    // The transaction ID of the transaction.
    //
    // If submission was unsuccessful and error will be returned.
    bytes transaction_ID = 1;
}

message SweepWalletRequest {
    // Address to send funds to
    string to_address                = 1;
    // The fee to use for the transaction in nanoillium.
    // If zero the wallet will use its internal fee policy.
    uint64 fee_per_kilobyte          = 2;
    // An optional list of input commitments to sweep. If this
    // is empty the entire wallet will be swept.
    //
    // Note that staked commitments will not be selected by
    // the wallet. You will need to list staked commitments
    // here if you wish to sweep them.
    repeated bytes input_commitments = 3;
}
message SweepWalletResponse {
    // The transaction ID of the transaction.
    //
    // If submission was unsuccessful and error will be returned.
    bytes transaction_ID = 1;
}

message SubscribeWalletTransactionsRequest {}
message SubscribeWalletSyncNotificationsRequest {}

// NodeService
message GetHostInfoRequest {}
message GetHostInfoResponse {
    // The host peer ID
    string peer_ID        = 1;
    // A list of multiaddrs that this node is listening on
    repeated string addrs = 2;
    // The number of peers this node is connected to
    uint32 peers          = 3;
    // The firewall status of the node
    string reachability   = 4;
    // Is tx index enabled
    bool tx_index         = 5;
    // Is the wallet server enabled
    bool wallet_server    = 6;
    // Is the proving server enabled
    bool proving_server   = 7;
}

message GetNetworkKeyRequest{}
message GetNetworkKeyResponse{
    // The nodes' serialized network key
    bytes networkPrivateKey = 1;
}

message GetPeersRequest {}
message GetPeersResponse {
    // List of peers
    repeated Peer peers = 1;
}

message GetPeerInfoRequest {
    // Peer ID to get info about
    string peer_ID = 1;
}
message GetPeerInfoResponse {
    // Info about the peer
    Peer peer = 1;
}

message AddPeerRequest {
    // The peer addr to add. The IP addresses for the peer
    // will be looked up in the DHT if necessary.
    string peer_ID = 1;
}
message AddPeerResponse {}

message BlockPeerRequest {
    // Peer ID to block
    string peer_ID = 1;
}
message BlockPeerResponse {}

message UnblockPeerRequest {
    // Peer ID to unblock
    string peer_ID = 1;
}
message UnblockPeerResponse {}

message SetLogLevelRequest {
    // The debug level to set the logging to
    Level level = 1;

    enum Level {
       TRACE   = 0;
       DEBUG   = 1;
       INFO    = 2;
       WARNING = 3;
       ERROR   = 4;
       FATAL   = 5;
    }
}
message SetLogLevelResponse {}

message GetMinFeePerKilobyteRequest {}
message GetMinFeePerKilobyteResponse {
    // Fee per kilobyte response in nanoillium
    uint64 fee_per_kilobyte = 1;
}

message SetMinFeePerKilobyteRequest {
    // Fee per byte to set in nanoillium
    uint64 fee_per_kilobyte = 1;
}
message SetMinFeePerKilobyteResponse {}

message GetMinStakeRequest {}
message GetMinStakeResponse {
    // Minimum stake response in nanoillium
    uint64 min_stake_amount = 1;
}

message SetMinStakeRequest {
    // Minimum stake amount to set in nanoillium
    uint64 min_stake_amount = 1;
}
message SetMinStakeResponse {}

message GetBlockSizeSoftLimitRequest {}
message GetBlockSizeSoftLimitResponse {
    // Block size response
    uint32 block_size = 1;
}

message SetBlockSizeSoftLimitRequest {
    // Blocksize to set
    uint32 block_size = 1;
}
message SetBlockSizeSoftLimitResponse {}

message GetTreasuryWhitelistRequest {}
message GetTreasuryWhitelistResponse {
    // Whitelisted txids
    repeated bytes txids = 1;
}

message UpdateTreasuryWhitelistRequest {
    // Txids to add to the whitelist
    repeated bytes add    = 1;
    // Txids to remove from the whitelist
    repeated bytes remove = 2;
}
message UpdateTreasuryWhitelistResponse {}

message ReconsiderBlockRequest {
    // Block ID to reconsider.
    bytes block_ID = 1;
    // We likely don't have the block and will have to download it from
    // another peer. You can set the peer here. If empty we will try to find
    // it form a few random peers.
    string download_peer = 2;
}
message ReconsiderBlockResponse {}

message RecomputeChainStateRequest {}
message RecomputeChainStateResponse {}

// NOTIFICATIONS
message TransactionNotification {
    // The transaction in this notification has finalized and
    // been added to the blockchain.
    Transaction transaction = 1;
    // The ID of the block containing the transaction
    bytes block_ID          = 2;
    // The height of the block containing the transaction
    uint32 block_height     = 3;
}

message WalletTransactionNotification {
    // The transaction in this notification has finalized and
    // been added to the blockchain.
    WalletTransaction transaction = 1;
    // The ID of the block containing the transaction
    bytes block_ID                = 2;
    // The height of the block containing the transaction
    uint32 block_height           = 3;
}

message WalletSyncNotification {
    // The current height the wallet is synced up to
    uint32 current_height = 1;
    // The height of the chain that the wallet is syncing to
    uint32 best_height    = 2;
}

message BlockNotification {
    // The BlockInfo (including header data) for the block
    BlockInfo block_info                  = 1;
    // The blocks transactions (if requested).
    //
    // The transactions will either be returned in for or just the txids depending
    // on the request.
    repeated TransactionData transactions = 2;
}

message CompressedBlockNotification {
    // A compressed block containing only the height,
    // txids, outputs, and nullifiers.
    CompressedBlock block = 1;
}

// DATA MESSAGES
message TransactionData {
    oneof txids_or_txs {
        // Just the transaction ID
        bytes transaction_ID    = 1;
        // A marshaled transaction.
        Transaction transaction = 2;
    }
}

message BlockInfo {
    // The hash of the block header.
    bytes  block_ID   = 1;
    // A version number to track software/protocol upgrades.
    uint32 version    = 2;
    // The height of the block in the chain.
    uint32 height     = 3;
    // The block in the chain right before this one.
    bytes parent      = 4;
    // The next block in the chain (or nil if this block is the tip).
    bytes child       = 5;
    // The timestamp of the block. Expressed in seconds since 1970-01-01.
    int64 timestamp   = 6;
    // The root of the Merkle Tree built from all transactions in the block.
    bytes tx_root     = 7;
    // The peerID of the validator that created the block.
    bytes producer_ID = 8;
    // The size of the block in bytes.
    uint32 size       = 9;
    // The number of transactions in the block.
    uint32 num_txs    = 10;
    // The total transaction fees in the block.
    uint64 total_fees = 11;
}

message Validator {
        // The validator ID encoded in bytes.
        bytes validator_ID     = 1;
        // The number of coins staked by this validator in nanoillium.
        uint64 total_stake     = 2;
        // The total stake weighted by time lock in nanoillium.
        uint64 stake_weight    = 3;
        // The nullifiers for the utxos the validator has staked.
        repeated Stake stake   = 4;
        // The total of any unclaimed validator rewards in nanoillium.
        uint64 unclaimed_coins = 5;
        // The number of blocks this validator has created this epoch.
        uint32 epoch_blocks    = 6;

        message Stake {
            // The nullifier that is staked
            bytes nullifier           = 1;
            // The amount staked in nanoillium
            uint64 amount             = 2;
            // The timestamp that this utxo is timelocked until
            int64 timelocked_until    = 3;
            // When this nullifier will expire and be removed from
            // the validator set.
            int64 expiration          = 4;
            // The earliest date at which this nullifier can be restaked.
            // One week before expiration.
            int64 restake_eligibility = 5;
        }
}

message Utxo {
    // The commitment associated with the output
    bytes commitment    = 1;
    // The amount of coins in nanoillium
    uint64 amount       = 2;
    // The address that the utxo is associated with
    string address      = 3;
    // Whether or not this is a watch only utxo.
    // We canot spend watch only utxos without the
    // private key.
    bool watchOnly      = 4;
    // Is this utxo staked by the wallet.
    bool staked         = 5;
    // The timestamp this utxo is timelocked until (if applicable)
    int64 locked_untill = 6;
}

message RawTransaction {
    // The transaction as it appears on the network
    Transaction tx                 = 1;
    // The private (hidden) data for each input
    repeated PrivateInput inputs   = 2;
    // The private (hidden) data for each output
    repeated PrivateOutput outputs = 3;
}

message PrivateInput {
    // The amount of the input in nanoillium
    uint64 amount                 = 1;
    // Input asset ID
    bytes asset_ID                = 2;
    // Input salt
    bytes salt                    = 3;
    // Input state
    bytes state                   = 4;
    // The txo proof linking the input
    // commitment to the accumulator
    TxoProof txo_proof            = 5;
    // The locking script
    string script                 = 6;
    // The locking function parameters
    repeated bytes locking_params = 7;
    // Optional lurk expression used as
    // input to locking script. This is
    // only necessary for watch-only utxos.
    string unlocking_params       = 8;
}

message PrivateOutput {
    // Output scriptHash
    bytes script_hash = 1;
    // Output amount in nanoillium
    uint64 amount     = 2;
    // Output salt
    bytes salt        = 3;
    // Output asset ID
    bytes asset_ID    = 4;
    // Output state
    bytes state       = 5;
}

message TxoProof {
    // The commitment this inclusion proof is for
    bytes commitment      = 1;
    // The hashes that form the root preimage
    repeated bytes hashes = 2;
    // Flags indicate whether a hash in the hash list is left or right.
    // 0 == left, 1 == right.
    uint64 flags          = 3;
    // The index of this commitment in the tree
    uint64 index          = 4;
    // The txoRoot this proof links to. This is found in the block header.
    bytes txoRoot         = 5;
}

message Peer {
    // Peer ID
    string id             = 1;
    // The peer's user agent string
    string user_agent     = 2;
    // Multiaddrs
    repeated string addrs = 3;
}

message WalletTransaction {
    // Transaction ID
    bytes transaction_ID = 1;
    // The net number of coins coming into the wallet in nanoillium
    // Positive = receive
    // Negative = send
    int64 netCoins      = 2;
    // The address and amount of each input if known
    // to the wallet.
    repeated IOMetadata inputs  = 3;
    // The address and amount of each output if known
    // to the wallet.
    repeated IOMetadata outputs = 4;
}

message IOMetadata {
    // Either address/amount information or unknown
    // if input or output did not belong to this wallet
    // and can't be decrypted.
    oneof io_type {
        TxIO tx_io      = 1;
        Unknown unknown = 2;
    }

    message TxIO {
        // Address associated with the input or output
        string address = 1;
        // Amount of coins associated with the input or output in nanoillium
        uint64 amount  = 2;
    }

    // Represents an input or output not belonging to
    // the wallet.
    message Unknown {}
}