// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: ilxrpc.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BlockchainServiceClient is the client API for BlockchainService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BlockchainServiceClient interface {
	// GetMempoolInfo returns the state of the current mempool
	GetMempoolInfo(ctx context.Context, in *GetMempoolInfoRequest, opts ...grpc.CallOption) (*GetMempoolInfoResponse, error)
	// GetMempool returns all the transactions in the mempool
	GetMempool(ctx context.Context, in *GetMempoolRequest, opts ...grpc.CallOption) (*GetMempoolResponse, error)
	// GetBlockchainInfo returns data about the blockchain including the most recent
	// block hash and height.
	GetBlockchainInfo(ctx context.Context, in *GetBlockchainInfoRequest, opts ...grpc.CallOption) (*GetBlockchainInfoResponse, error)
	// GetBlockInfo returns a BlockHeader plus some extra metadata.
	GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error)
	// GetBlock returns the detailed data for a block.
	GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error)
	// GetCompressedBlock returns a block that is stripped down to just the outputs.
	// It is the bare minimum information a client side wallet needs to compute its internal
	// state.
	GetCompressedBlock(ctx context.Context, in *GetCompressedBlockRequest, opts ...grpc.CallOption) (*GetCompressedBlockResponse, error)
	// GetHeaders returns a batch of headers according to the request parameters.
	GetHeaders(ctx context.Context, in *GetHeadersRequest, opts ...grpc.CallOption) (*GetHeadersResponse, error)
	// GetCompressedBlocks returns a batch of CompressedBlocks according to the request parameters.
	GetCompressedBlocks(ctx context.Context, in *GetCompressedBlocksRequest, opts ...grpc.CallOption) (*GetCompressedBlocksResponse, error)
	// GetTransaction returns the transaction for the given transaction ID.
	//
	// **Requires TxIndex**
	// **Input/Output metadata requires AddrIndex**
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
	// GetAddressTransactions returns a list of transactions for the given address
	// Note: only public address are indexed
	//
	// **Requires AddrIndex**
	GetAddressTransactions(ctx context.Context, in *GetAddressTransactionsRequest, opts ...grpc.CallOption) (*GetAddressTransactionsResponse, error)
	// GetMerkleProof returns a Merkle (SPV) proof for a specific transaction
	// in the provided block.
	//
	// **Requires TxIndex**
	GetMerkleProof(ctx context.Context, in *GetMerkleProofRequest, opts ...grpc.CallOption) (*GetMerkleProofResponse, error)
	// GetValidator returns all the information about the given validator including number
	// of staked coins.
	GetValidator(ctx context.Context, in *GetValidatorRequest, opts ...grpc.CallOption) (*GetValidatorResponse, error)
	// GetValidatorSetInfo returns information about the validator set.
	GetValidatorSetInfo(ctx context.Context, in *GetValidatorSetInfoRequest, opts ...grpc.CallOption) (*GetValidatorSetInfoResponse, error)
	// GetValidatorSet returns all the validators in the current validator set.
	GetValidatorSet(ctx context.Context, in *GetValidatorSetRequest, opts ...grpc.CallOption) (*GetValidatorSetResponse, error)
	// GetAccumulatorCheckpoint returns the accumulator at the requested height.
	// If there is no checkpoint at that height, the *prior* checkpoint found in the
	// chain will be returned. If there is no prior checkpoint (as is prior to the first)
	// an error will be returned.
	GetAccumulatorCheckpoint(ctx context.Context, in *GetAccumulatorCheckpointRequest, opts ...grpc.CallOption) (*GetAccumulatorCheckpointResponse, error)
	// SubmitTransaction validates a transaction and submits it to the network. An error will be returned
	// if it fails validation.
	SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error)
	// SubscribeBlocks returns a stream of notifications when new blocks are finalized and
	// connected to the chain.
	SubscribeBlocks(ctx context.Context, in *SubscribeBlocksRequest, opts ...grpc.CallOption) (BlockchainService_SubscribeBlocksClient, error)
	// SubscribeCompressedBlocks returns a stream of CompressedBlock notifications when new
	// blocks are finalized and connected to the chain.
	SubscribeCompressedBlocks(ctx context.Context, in *SubscribeCompressedBlocksRequest, opts ...grpc.CallOption) (BlockchainService_SubscribeCompressedBlocksClient, error)
}

type blockchainServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBlockchainServiceClient(cc grpc.ClientConnInterface) BlockchainServiceClient {
	return &blockchainServiceClient{cc}
}

func (c *blockchainServiceClient) GetMempoolInfo(ctx context.Context, in *GetMempoolInfoRequest, opts ...grpc.CallOption) (*GetMempoolInfoResponse, error) {
	out := new(GetMempoolInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetMempoolInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetMempool(ctx context.Context, in *GetMempoolRequest, opts ...grpc.CallOption) (*GetMempoolResponse, error) {
	out := new(GetMempoolResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetMempool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetBlockchainInfo(ctx context.Context, in *GetBlockchainInfoRequest, opts ...grpc.CallOption) (*GetBlockchainInfoResponse, error) {
	out := new(GetBlockchainInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetBlockchainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoResponse, error) {
	out := new(GetBlockInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetBlockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error) {
	out := new(GetBlockResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetCompressedBlock(ctx context.Context, in *GetCompressedBlockRequest, opts ...grpc.CallOption) (*GetCompressedBlockResponse, error) {
	out := new(GetCompressedBlockResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetCompressedBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetHeaders(ctx context.Context, in *GetHeadersRequest, opts ...grpc.CallOption) (*GetHeadersResponse, error) {
	out := new(GetHeadersResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetHeaders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetCompressedBlocks(ctx context.Context, in *GetCompressedBlocksRequest, opts ...grpc.CallOption) (*GetCompressedBlocksResponse, error) {
	out := new(GetCompressedBlocksResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetCompressedBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetAddressTransactions(ctx context.Context, in *GetAddressTransactionsRequest, opts ...grpc.CallOption) (*GetAddressTransactionsResponse, error) {
	out := new(GetAddressTransactionsResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetAddressTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetMerkleProof(ctx context.Context, in *GetMerkleProofRequest, opts ...grpc.CallOption) (*GetMerkleProofResponse, error) {
	out := new(GetMerkleProofResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetMerkleProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetValidator(ctx context.Context, in *GetValidatorRequest, opts ...grpc.CallOption) (*GetValidatorResponse, error) {
	out := new(GetValidatorResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetValidatorSetInfo(ctx context.Context, in *GetValidatorSetInfoRequest, opts ...grpc.CallOption) (*GetValidatorSetInfoResponse, error) {
	out := new(GetValidatorSetInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetValidatorSetInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetValidatorSet(ctx context.Context, in *GetValidatorSetRequest, opts ...grpc.CallOption) (*GetValidatorSetResponse, error) {
	out := new(GetValidatorSetResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetValidatorSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) GetAccumulatorCheckpoint(ctx context.Context, in *GetAccumulatorCheckpointRequest, opts ...grpc.CallOption) (*GetAccumulatorCheckpointResponse, error) {
	out := new(GetAccumulatorCheckpointResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/GetAccumulatorCheckpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) SubmitTransaction(ctx context.Context, in *SubmitTransactionRequest, opts ...grpc.CallOption) (*SubmitTransactionResponse, error) {
	out := new(SubmitTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.BlockchainService/SubmitTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blockchainServiceClient) SubscribeBlocks(ctx context.Context, in *SubscribeBlocksRequest, opts ...grpc.CallOption) (BlockchainService_SubscribeBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &BlockchainService_ServiceDesc.Streams[0], "/pb.BlockchainService/SubscribeBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainServiceSubscribeBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BlockchainService_SubscribeBlocksClient interface {
	Recv() (*BlockNotification, error)
	grpc.ClientStream
}

type blockchainServiceSubscribeBlocksClient struct {
	grpc.ClientStream
}

func (x *blockchainServiceSubscribeBlocksClient) Recv() (*BlockNotification, error) {
	m := new(BlockNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *blockchainServiceClient) SubscribeCompressedBlocks(ctx context.Context, in *SubscribeCompressedBlocksRequest, opts ...grpc.CallOption) (BlockchainService_SubscribeCompressedBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &BlockchainService_ServiceDesc.Streams[1], "/pb.BlockchainService/SubscribeCompressedBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &blockchainServiceSubscribeCompressedBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BlockchainService_SubscribeCompressedBlocksClient interface {
	Recv() (*CompressedBlockNotification, error)
	grpc.ClientStream
}

type blockchainServiceSubscribeCompressedBlocksClient struct {
	grpc.ClientStream
}

func (x *blockchainServiceSubscribeCompressedBlocksClient) Recv() (*CompressedBlockNotification, error) {
	m := new(CompressedBlockNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BlockchainServiceServer is the server API for BlockchainService service.
// All implementations must embed UnimplementedBlockchainServiceServer
// for forward compatibility
type BlockchainServiceServer interface {
	// GetMempoolInfo returns the state of the current mempool
	GetMempoolInfo(context.Context, *GetMempoolInfoRequest) (*GetMempoolInfoResponse, error)
	// GetMempool returns all the transactions in the mempool
	GetMempool(context.Context, *GetMempoolRequest) (*GetMempoolResponse, error)
	// GetBlockchainInfo returns data about the blockchain including the most recent
	// block hash and height.
	GetBlockchainInfo(context.Context, *GetBlockchainInfoRequest) (*GetBlockchainInfoResponse, error)
	// GetBlockInfo returns a BlockHeader plus some extra metadata.
	GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoResponse, error)
	// GetBlock returns the detailed data for a block.
	GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error)
	// GetCompressedBlock returns a block that is stripped down to just the outputs.
	// It is the bare minimum information a client side wallet needs to compute its internal
	// state.
	GetCompressedBlock(context.Context, *GetCompressedBlockRequest) (*GetCompressedBlockResponse, error)
	// GetHeaders returns a batch of headers according to the request parameters.
	GetHeaders(context.Context, *GetHeadersRequest) (*GetHeadersResponse, error)
	// GetCompressedBlocks returns a batch of CompressedBlocks according to the request parameters.
	GetCompressedBlocks(context.Context, *GetCompressedBlocksRequest) (*GetCompressedBlocksResponse, error)
	// GetTransaction returns the transaction for the given transaction ID.
	//
	// **Requires TxIndex**
	// **Input/Output metadata requires AddrIndex**
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
	// GetAddressTransactions returns a list of transactions for the given address
	// Note: only public address are indexed
	//
	// **Requires AddrIndex**
	GetAddressTransactions(context.Context, *GetAddressTransactionsRequest) (*GetAddressTransactionsResponse, error)
	// GetMerkleProof returns a Merkle (SPV) proof for a specific transaction
	// in the provided block.
	//
	// **Requires TxIndex**
	GetMerkleProof(context.Context, *GetMerkleProofRequest) (*GetMerkleProofResponse, error)
	// GetValidator returns all the information about the given validator including number
	// of staked coins.
	GetValidator(context.Context, *GetValidatorRequest) (*GetValidatorResponse, error)
	// GetValidatorSetInfo returns information about the validator set.
	GetValidatorSetInfo(context.Context, *GetValidatorSetInfoRequest) (*GetValidatorSetInfoResponse, error)
	// GetValidatorSet returns all the validators in the current validator set.
	GetValidatorSet(context.Context, *GetValidatorSetRequest) (*GetValidatorSetResponse, error)
	// GetAccumulatorCheckpoint returns the accumulator at the requested height.
	// If there is no checkpoint at that height, the *prior* checkpoint found in the
	// chain will be returned. If there is no prior checkpoint (as is prior to the first)
	// an error will be returned.
	GetAccumulatorCheckpoint(context.Context, *GetAccumulatorCheckpointRequest) (*GetAccumulatorCheckpointResponse, error)
	// SubmitTransaction validates a transaction and submits it to the network. An error will be returned
	// if it fails validation.
	SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error)
	// SubscribeBlocks returns a stream of notifications when new blocks are finalized and
	// connected to the chain.
	SubscribeBlocks(*SubscribeBlocksRequest, BlockchainService_SubscribeBlocksServer) error
	// SubscribeCompressedBlocks returns a stream of CompressedBlock notifications when new
	// blocks are finalized and connected to the chain.
	SubscribeCompressedBlocks(*SubscribeCompressedBlocksRequest, BlockchainService_SubscribeCompressedBlocksServer) error
	mustEmbedUnimplementedBlockchainServiceServer()
}

// UnimplementedBlockchainServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBlockchainServiceServer struct {
}

func (UnimplementedBlockchainServiceServer) GetMempoolInfo(context.Context, *GetMempoolInfoRequest) (*GetMempoolInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMempoolInfo not implemented")
}
func (UnimplementedBlockchainServiceServer) GetMempool(context.Context, *GetMempoolRequest) (*GetMempoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMempool not implemented")
}
func (UnimplementedBlockchainServiceServer) GetBlockchainInfo(context.Context, *GetBlockchainInfoRequest) (*GetBlockchainInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockchainInfo not implemented")
}
func (UnimplementedBlockchainServiceServer) GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}
func (UnimplementedBlockchainServiceServer) GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedBlockchainServiceServer) GetCompressedBlock(context.Context, *GetCompressedBlockRequest) (*GetCompressedBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompressedBlock not implemented")
}
func (UnimplementedBlockchainServiceServer) GetHeaders(context.Context, *GetHeadersRequest) (*GetHeadersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHeaders not implemented")
}
func (UnimplementedBlockchainServiceServer) GetCompressedBlocks(context.Context, *GetCompressedBlocksRequest) (*GetCompressedBlocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompressedBlocks not implemented")
}
func (UnimplementedBlockchainServiceServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedBlockchainServiceServer) GetAddressTransactions(context.Context, *GetAddressTransactionsRequest) (*GetAddressTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressTransactions not implemented")
}
func (UnimplementedBlockchainServiceServer) GetMerkleProof(context.Context, *GetMerkleProofRequest) (*GetMerkleProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMerkleProof not implemented")
}
func (UnimplementedBlockchainServiceServer) GetValidator(context.Context, *GetValidatorRequest) (*GetValidatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidator not implemented")
}
func (UnimplementedBlockchainServiceServer) GetValidatorSetInfo(context.Context, *GetValidatorSetInfoRequest) (*GetValidatorSetInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorSetInfo not implemented")
}
func (UnimplementedBlockchainServiceServer) GetValidatorSet(context.Context, *GetValidatorSetRequest) (*GetValidatorSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorSet not implemented")
}
func (UnimplementedBlockchainServiceServer) GetAccumulatorCheckpoint(context.Context, *GetAccumulatorCheckpointRequest) (*GetAccumulatorCheckpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccumulatorCheckpoint not implemented")
}
func (UnimplementedBlockchainServiceServer) SubmitTransaction(context.Context, *SubmitTransactionRequest) (*SubmitTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTransaction not implemented")
}
func (UnimplementedBlockchainServiceServer) SubscribeBlocks(*SubscribeBlocksRequest, BlockchainService_SubscribeBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeBlocks not implemented")
}
func (UnimplementedBlockchainServiceServer) SubscribeCompressedBlocks(*SubscribeCompressedBlocksRequest, BlockchainService_SubscribeCompressedBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeCompressedBlocks not implemented")
}
func (UnimplementedBlockchainServiceServer) mustEmbedUnimplementedBlockchainServiceServer() {}

// UnsafeBlockchainServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BlockchainServiceServer will
// result in compilation errors.
type UnsafeBlockchainServiceServer interface {
	mustEmbedUnimplementedBlockchainServiceServer()
}

func RegisterBlockchainServiceServer(s grpc.ServiceRegistrar, srv BlockchainServiceServer) {
	s.RegisterService(&BlockchainService_ServiceDesc, srv)
}

func _BlockchainService_GetMempoolInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMempoolInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetMempoolInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetMempoolInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetMempoolInfo(ctx, req.(*GetMempoolInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetMempool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMempoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetMempool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetMempool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetMempool(ctx, req.(*GetMempoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetBlockchainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockchainInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetBlockchainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetBlockchainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetBlockchainInfo(ctx, req.(*GetBlockchainInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetBlockInfo(ctx, req.(*GetBlockInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetBlock(ctx, req.(*GetBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetCompressedBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCompressedBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetCompressedBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetCompressedBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetCompressedBlock(ctx, req.(*GetCompressedBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetHeaders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHeadersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetHeaders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetHeaders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetHeaders(ctx, req.(*GetHeadersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetCompressedBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCompressedBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetCompressedBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetCompressedBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetCompressedBlocks(ctx, req.(*GetCompressedBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetAddressTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetAddressTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetAddressTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetAddressTransactions(ctx, req.(*GetAddressTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetMerkleProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMerkleProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetMerkleProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetMerkleProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetMerkleProof(ctx, req.(*GetMerkleProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetValidator(ctx, req.(*GetValidatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetValidatorSetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorSetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetValidatorSetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetValidatorSetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetValidatorSetInfo(ctx, req.(*GetValidatorSetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetValidatorSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetValidatorSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetValidatorSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetValidatorSet(ctx, req.(*GetValidatorSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_GetAccumulatorCheckpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccumulatorCheckpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).GetAccumulatorCheckpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/GetAccumulatorCheckpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).GetAccumulatorCheckpoint(ctx, req.(*GetAccumulatorCheckpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_SubmitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BlockchainServiceServer).SubmitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.BlockchainService/SubmitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BlockchainServiceServer).SubmitTransaction(ctx, req.(*SubmitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BlockchainService_SubscribeBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeBlocksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServiceServer).SubscribeBlocks(m, &blockchainServiceSubscribeBlocksServer{stream})
}

type BlockchainService_SubscribeBlocksServer interface {
	Send(*BlockNotification) error
	grpc.ServerStream
}

type blockchainServiceSubscribeBlocksServer struct {
	grpc.ServerStream
}

func (x *blockchainServiceSubscribeBlocksServer) Send(m *BlockNotification) error {
	return x.ServerStream.SendMsg(m)
}

func _BlockchainService_SubscribeCompressedBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeCompressedBlocksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BlockchainServiceServer).SubscribeCompressedBlocks(m, &blockchainServiceSubscribeCompressedBlocksServer{stream})
}

type BlockchainService_SubscribeCompressedBlocksServer interface {
	Send(*CompressedBlockNotification) error
	grpc.ServerStream
}

type blockchainServiceSubscribeCompressedBlocksServer struct {
	grpc.ServerStream
}

func (x *blockchainServiceSubscribeCompressedBlocksServer) Send(m *CompressedBlockNotification) error {
	return x.ServerStream.SendMsg(m)
}

// BlockchainService_ServiceDesc is the grpc.ServiceDesc for BlockchainService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BlockchainService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.BlockchainService",
	HandlerType: (*BlockchainServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMempoolInfo",
			Handler:    _BlockchainService_GetMempoolInfo_Handler,
		},
		{
			MethodName: "GetMempool",
			Handler:    _BlockchainService_GetMempool_Handler,
		},
		{
			MethodName: "GetBlockchainInfo",
			Handler:    _BlockchainService_GetBlockchainInfo_Handler,
		},
		{
			MethodName: "GetBlockInfo",
			Handler:    _BlockchainService_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BlockchainService_GetBlock_Handler,
		},
		{
			MethodName: "GetCompressedBlock",
			Handler:    _BlockchainService_GetCompressedBlock_Handler,
		},
		{
			MethodName: "GetHeaders",
			Handler:    _BlockchainService_GetHeaders_Handler,
		},
		{
			MethodName: "GetCompressedBlocks",
			Handler:    _BlockchainService_GetCompressedBlocks_Handler,
		},
		{
			MethodName: "GetTransaction",
			Handler:    _BlockchainService_GetTransaction_Handler,
		},
		{
			MethodName: "GetAddressTransactions",
			Handler:    _BlockchainService_GetAddressTransactions_Handler,
		},
		{
			MethodName: "GetMerkleProof",
			Handler:    _BlockchainService_GetMerkleProof_Handler,
		},
		{
			MethodName: "GetValidator",
			Handler:    _BlockchainService_GetValidator_Handler,
		},
		{
			MethodName: "GetValidatorSetInfo",
			Handler:    _BlockchainService_GetValidatorSetInfo_Handler,
		},
		{
			MethodName: "GetValidatorSet",
			Handler:    _BlockchainService_GetValidatorSet_Handler,
		},
		{
			MethodName: "GetAccumulatorCheckpoint",
			Handler:    _BlockchainService_GetAccumulatorCheckpoint_Handler,
		},
		{
			MethodName: "SubmitTransaction",
			Handler:    _BlockchainService_SubmitTransaction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeBlocks",
			Handler:       _BlockchainService_SubscribeBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeCompressedBlocks",
			Handler:       _BlockchainService_SubscribeCompressedBlocks_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ilxrpc.proto",
}

// WalletServerServiceClient is the client API for WalletServerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WalletServerServiceClient interface {
	// RegisterViewKey registers a new view key with the server. The server will use this key when
	// attempting to decrypt each output. If outputs decrypt, they will be indexed so the client
	// can fetch them later.
	//
	// To free up resources keys will automatically unregister if the wallet has not connected
	// in some time.
	RegisterViewKey(ctx context.Context, in *RegisterViewKeyRequest, opts ...grpc.CallOption) (*RegisterViewKeyResponse, error)
	// SubscribeTransactions subscribes to a stream of TransactionsNotifications that match to the
	// provided view key.
	SubscribeTransactions(ctx context.Context, in *SubscribeTransactionsRequest, opts ...grpc.CallOption) (WalletServerService_SubscribeTransactionsClient, error)
	// GetWalletTransactions returns a list of transactions for the provided view key.
	GetWalletTransactions(ctx context.Context, in *GetWalletTransactionsRequest, opts ...grpc.CallOption) (*GetWalletTransactionsResponse, error)
	// GetTxoProof returns the merkle inclusion proof for the given commitment. This information is needed
	// by the client to create the zero knowledge proof needed to spend the transaction.
	GetTxoProof(ctx context.Context, in *GetTxoProofRequest, opts ...grpc.CallOption) (*GetTxoProofResponse, error)
}

type walletServerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWalletServerServiceClient(cc grpc.ClientConnInterface) WalletServerServiceClient {
	return &walletServerServiceClient{cc}
}

func (c *walletServerServiceClient) RegisterViewKey(ctx context.Context, in *RegisterViewKeyRequest, opts ...grpc.CallOption) (*RegisterViewKeyResponse, error) {
	out := new(RegisterViewKeyResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletServerService/RegisterViewKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServerServiceClient) SubscribeTransactions(ctx context.Context, in *SubscribeTransactionsRequest, opts ...grpc.CallOption) (WalletServerService_SubscribeTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &WalletServerService_ServiceDesc.Streams[0], "/pb.WalletServerService/SubscribeTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &walletServerServiceSubscribeTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WalletServerService_SubscribeTransactionsClient interface {
	Recv() (*TransactionNotification, error)
	grpc.ClientStream
}

type walletServerServiceSubscribeTransactionsClient struct {
	grpc.ClientStream
}

func (x *walletServerServiceSubscribeTransactionsClient) Recv() (*TransactionNotification, error) {
	m := new(TransactionNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *walletServerServiceClient) GetWalletTransactions(ctx context.Context, in *GetWalletTransactionsRequest, opts ...grpc.CallOption) (*GetWalletTransactionsResponse, error) {
	out := new(GetWalletTransactionsResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletServerService/GetWalletTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServerServiceClient) GetTxoProof(ctx context.Context, in *GetTxoProofRequest, opts ...grpc.CallOption) (*GetTxoProofResponse, error) {
	out := new(GetTxoProofResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletServerService/GetTxoProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WalletServerServiceServer is the server API for WalletServerService service.
// All implementations must embed UnimplementedWalletServerServiceServer
// for forward compatibility
type WalletServerServiceServer interface {
	// RegisterViewKey registers a new view key with the server. The server will use this key when
	// attempting to decrypt each output. If outputs decrypt, they will be indexed so the client
	// can fetch them later.
	//
	// To free up resources keys will automatically unregister if the wallet has not connected
	// in some time.
	RegisterViewKey(context.Context, *RegisterViewKeyRequest) (*RegisterViewKeyResponse, error)
	// SubscribeTransactions subscribes to a stream of TransactionsNotifications that match to the
	// provided view key.
	SubscribeTransactions(*SubscribeTransactionsRequest, WalletServerService_SubscribeTransactionsServer) error
	// GetWalletTransactions returns a list of transactions for the provided view key.
	GetWalletTransactions(context.Context, *GetWalletTransactionsRequest) (*GetWalletTransactionsResponse, error)
	// GetTxoProof returns the merkle inclusion proof for the given commitment. This information is needed
	// by the client to create the zero knowledge proof needed to spend the transaction.
	GetTxoProof(context.Context, *GetTxoProofRequest) (*GetTxoProofResponse, error)
	mustEmbedUnimplementedWalletServerServiceServer()
}

// UnimplementedWalletServerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWalletServerServiceServer struct {
}

func (UnimplementedWalletServerServiceServer) RegisterViewKey(context.Context, *RegisterViewKeyRequest) (*RegisterViewKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterViewKey not implemented")
}
func (UnimplementedWalletServerServiceServer) SubscribeTransactions(*SubscribeTransactionsRequest, WalletServerService_SubscribeTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTransactions not implemented")
}
func (UnimplementedWalletServerServiceServer) GetWalletTransactions(context.Context, *GetWalletTransactionsRequest) (*GetWalletTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWalletTransactions not implemented")
}
func (UnimplementedWalletServerServiceServer) GetTxoProof(context.Context, *GetTxoProofRequest) (*GetTxoProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxoProof not implemented")
}
func (UnimplementedWalletServerServiceServer) mustEmbedUnimplementedWalletServerServiceServer() {}

// UnsafeWalletServerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WalletServerServiceServer will
// result in compilation errors.
type UnsafeWalletServerServiceServer interface {
	mustEmbedUnimplementedWalletServerServiceServer()
}

func RegisterWalletServerServiceServer(s grpc.ServiceRegistrar, srv WalletServerServiceServer) {
	s.RegisterService(&WalletServerService_ServiceDesc, srv)
}

func _WalletServerService_RegisterViewKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterViewKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServerServiceServer).RegisterViewKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletServerService/RegisterViewKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServerServiceServer).RegisterViewKey(ctx, req.(*RegisterViewKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletServerService_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WalletServerServiceServer).SubscribeTransactions(m, &walletServerServiceSubscribeTransactionsServer{stream})
}

type WalletServerService_SubscribeTransactionsServer interface {
	Send(*TransactionNotification) error
	grpc.ServerStream
}

type walletServerServiceSubscribeTransactionsServer struct {
	grpc.ServerStream
}

func (x *walletServerServiceSubscribeTransactionsServer) Send(m *TransactionNotification) error {
	return x.ServerStream.SendMsg(m)
}

func _WalletServerService_GetWalletTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWalletTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServerServiceServer).GetWalletTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletServerService/GetWalletTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServerServiceServer).GetWalletTransactions(ctx, req.(*GetWalletTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletServerService_GetTxoProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxoProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServerServiceServer).GetTxoProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletServerService/GetTxoProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServerServiceServer).GetTxoProof(ctx, req.(*GetTxoProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WalletServerService_ServiceDesc is the grpc.ServiceDesc for WalletServerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WalletServerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.WalletServerService",
	HandlerType: (*WalletServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterViewKey",
			Handler:    _WalletServerService_RegisterViewKey_Handler,
		},
		{
			MethodName: "GetWalletTransactions",
			Handler:    _WalletServerService_GetWalletTransactions_Handler,
		},
		{
			MethodName: "GetTxoProof",
			Handler:    _WalletServerService_GetTxoProof_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeTransactions",
			Handler:       _WalletServerService_SubscribeTransactions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ilxrpc.proto",
}

// ProverServiceClient is the client API for ProverService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProverServiceClient interface {
	// Prove creates the proof for the transaction and returns the transaction
	// with the proof attached. The transaction is *not* submitted to the network.
	//
	// The transaction is validated against the mempool and will return an error
	// if it is an otherwise invalid transaction.
	Prove(ctx context.Context, in *ProveRequest, opts ...grpc.CallOption) (*ProveResponse, error)
	// ProveAndSubmit creates the proof for the transaction and then submits it to
	// the network. And error is returned if it fails mempool submission.
	ProveAndSubmit(ctx context.Context, in *ProveAndSubmitRequest, opts ...grpc.CallOption) (*ProveAndSubmitResponse, error)
}

type proverServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProverServiceClient(cc grpc.ClientConnInterface) ProverServiceClient {
	return &proverServiceClient{cc}
}

func (c *proverServiceClient) Prove(ctx context.Context, in *ProveRequest, opts ...grpc.CallOption) (*ProveResponse, error) {
	out := new(ProveResponse)
	err := c.cc.Invoke(ctx, "/pb.ProverService/Prove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *proverServiceClient) ProveAndSubmit(ctx context.Context, in *ProveAndSubmitRequest, opts ...grpc.CallOption) (*ProveAndSubmitResponse, error) {
	out := new(ProveAndSubmitResponse)
	err := c.cc.Invoke(ctx, "/pb.ProverService/ProveAndSubmit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProverServiceServer is the server API for ProverService service.
// All implementations must embed UnimplementedProverServiceServer
// for forward compatibility
type ProverServiceServer interface {
	// Prove creates the proof for the transaction and returns the transaction
	// with the proof attached. The transaction is *not* submitted to the network.
	//
	// The transaction is validated against the mempool and will return an error
	// if it is an otherwise invalid transaction.
	Prove(context.Context, *ProveRequest) (*ProveResponse, error)
	// ProveAndSubmit creates the proof for the transaction and then submits it to
	// the network. And error is returned if it fails mempool submission.
	ProveAndSubmit(context.Context, *ProveAndSubmitRequest) (*ProveAndSubmitResponse, error)
	mustEmbedUnimplementedProverServiceServer()
}

// UnimplementedProverServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProverServiceServer struct {
}

func (UnimplementedProverServiceServer) Prove(context.Context, *ProveRequest) (*ProveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prove not implemented")
}
func (UnimplementedProverServiceServer) ProveAndSubmit(context.Context, *ProveAndSubmitRequest) (*ProveAndSubmitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProveAndSubmit not implemented")
}
func (UnimplementedProverServiceServer) mustEmbedUnimplementedProverServiceServer() {}

// UnsafeProverServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProverServiceServer will
// result in compilation errors.
type UnsafeProverServiceServer interface {
	mustEmbedUnimplementedProverServiceServer()
}

func RegisterProverServiceServer(s grpc.ServiceRegistrar, srv ProverServiceServer) {
	s.RegisterService(&ProverService_ServiceDesc, srv)
}

func _ProverService_Prove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).Prove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ProverService/Prove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).Prove(ctx, req.(*ProveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProverService_ProveAndSubmit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProveAndSubmitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProverServiceServer).ProveAndSubmit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ProverService/ProveAndSubmit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProverServiceServer).ProveAndSubmit(ctx, req.(*ProveAndSubmitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProverService_ServiceDesc is the grpc.ServiceDesc for ProverService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProverService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ProverService",
	HandlerType: (*ProverServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Prove",
			Handler:    _ProverService_Prove_Handler,
		},
		{
			MethodName: "ProveAndSubmit",
			Handler:    _ProverService_ProveAndSubmit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ilxrpc.proto",
}

// WalletServiceClient is the client API for WalletService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WalletServiceClient interface {
	// GetBalance returns the combined balance of all addresses in the wallet
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	// GetWalletSeed returns the mnemonic seed for the wallet. If the wallet
	// seed has been deleted via the `DeletePrivateKeys` RPC an error will be
	// returned.
	//
	// **Requires wallet to be unlocked**
	GetWalletSeed(ctx context.Context, in *GetWalletSeedRequest, opts ...grpc.CallOption) (*GetWalletSeedResponse, error)
	// GetAddress returns the most recent address of the wallet.
	GetAddress(ctx context.Context, in *GetAddressRequest, opts ...grpc.CallOption) (*GetAddressResponse, error)
	// GetTimelockedAddress returns a timelocked address that cannot be spent
	// from until the given timelock has passed.
	//
	// The private key used for this address is the same as the wallet's most
	// recent spend key used in a basic address. This implies the key can be
	// derived from seed, however the wallet will not detect incoming payments
	// to this address unless the timelock is included in the utxo's state field.
	GetTimelockedAddress(ctx context.Context, in *GetTimelockedAddressRequest, opts ...grpc.CallOption) (*GetTimelockedAddressResponse, error)
	// GetPublicAddress returns a public address for the wallet. This address type
	// requires that the private output data that is normally encrypted with the
	// recipient's view key be put in the transaction in the clear.
	//
	// The private key used for this address is the same as the wallet's most
	// recent spend key used in a basic address. This implies the key can be
	// derived from seed.
	GetPublicAddress(ctx context.Context, in *GetPublicAddressRequest, opts ...grpc.CallOption) (*GetPublicAddressResponse, error)
	// GetAddresses returns all the addresses create by the wallet.
	GetAddresses(ctx context.Context, in *GetAddressesRequest, opts ...grpc.CallOption) (*GetAddressesResponse, error)
	// GetAddressInfo returns additional metadata about an address.
	GetAddressInfo(ctx context.Context, in *GetAddressInfoRequest, opts ...grpc.CallOption) (*GetAddressInfoResponse, error)
	// GetNewAddress generates a new address and returns it. Both a new spend key
	// and view key will be derived from the mnemonic seed.
	GetNewAddress(ctx context.Context, in *GetNewAddressRequest, opts ...grpc.CallOption) (*GetNewAddressResponse, error)
	// GetTransactions returns the list of transactions for the wallet
	GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*GetTransactionsResponse, error)
	// GetUtxos returns a list of the wallet's current unspent transaction outputs (UTXOs)
	GetUtxos(ctx context.Context, in *GetUtxosRequest, opts ...grpc.CallOption) (*GetUtxosResponse, error)
	// GetPrivateKey returns the serialized spend and view keys for the given address
	//
	// **Requires wallet to be unlocked**
	GetPrivateKey(ctx context.Context, in *GetPrivateKeyRequest, opts ...grpc.CallOption) (*GetPrivateKeyResponse, error)
	// ImportAddress imports a watch address into the wallet.
	ImportAddress(ctx context.Context, in *ImportAddressRequest, opts ...grpc.CallOption) (*ImportAddressResponse, error)
	// CreateMultisigSpendKeypair generates a spend keypair for use in a multisig address
	CreateMultisigSpendKeypair(ctx context.Context, in *CreateMultisigSpendKeypairRequest, opts ...grpc.CallOption) (*CreateMultisigSpendKeypairResponse, error)
	// CreateMultisigViewKeypair generates a view keypair for use in a multisig address
	CreateMultisigViewKeypair(ctx context.Context, in *CreateMultisigViewKeypairRequest, opts ...grpc.CallOption) (*CreateMultisigViewKeypairResponse, error)
	// CreateMultisigAddress generates a new multisig address using the provided public keys
	//
	// Note this address is *not* imported. You will need to call `ImportAddress` if you want to watch
	// it.
	CreateMultisigAddress(ctx context.Context, in *CreateMultisigAddressRequest, opts ...grpc.CallOption) (*CreateMultisigAddressResponse, error)
	// CreateMultiSignature generates and returns a signature for use when proving a multisig transaction
	CreateMultiSignature(ctx context.Context, in *CreateMultiSignatureRequest, opts ...grpc.CallOption) (*CreateMultiSignatureResponse, error)
	// ProveMultisig creates a proof for a transaction with a multisig input
	ProveMultisig(ctx context.Context, in *ProveMultisigRequest, opts ...grpc.CallOption) (*ProveMultisigResponse, error)
	// WalletLock encrypts the wallet's private keys
	WalletLock(ctx context.Context, in *WalletLockRequest, opts ...grpc.CallOption) (*WalletLockResponse, error)
	// WalletUnlock decrypts the wallet seed and holds it in memory for the specified period of time
	WalletUnlock(ctx context.Context, in *WalletUnlockRequest, opts ...grpc.CallOption) (*WalletUnlockResponse, error)
	// SetWalletPassphrase encrypts the wallet for the first time
	SetWalletPassphrase(ctx context.Context, in *SetWalletPassphraseRequest, opts ...grpc.CallOption) (*SetWalletPassphraseResponse, error)
	// ChangeWalletPassphrase changes the passphrase used to encrypt the wallet private keys
	ChangeWalletPassphrase(ctx context.Context, in *ChangeWalletPassphraseRequest, opts ...grpc.CallOption) (*ChangeWalletPassphraseResponse, error)
	// DeletePrivateKeys deletes the wallet's private keys and seed from disk essentially turning the wallet
	// into a watch-only wallet. It will still record incoming transactions but cannot spend them.
	//
	// **Requires wallet to be unlocked**
	DeletePrivateKeys(ctx context.Context, in *DeletePrivateKeysRequest, opts ...grpc.CallOption) (*DeletePrivateKeysResponse, error)
	// CreateRawTransaction creates a new, unsigned (unproven) transaction using the given parameters
	CreateRawTransaction(ctx context.Context, in *CreateRawTransactionRequest, opts ...grpc.CallOption) (*CreateRawTransactionResponse, error)
	// CreateRawStakeTransaction creates a new, unsigned (unproven) stake transaction using the given parameters
	CreateRawStakeTransaction(ctx context.Context, in *CreateRawStakeTransactionRequest, opts ...grpc.CallOption) (*CreateRawStakeTransactionResponse, error)
	// ProveRawTransaction creates the zk-proof for the transaction. Assuming there are no errors, this
	// transaction should be ready for broadcast.
	ProveRawTransaction(ctx context.Context, in *ProveRawTransactionRequest, opts ...grpc.CallOption) (*ProveRawTransactionResponse, error)
	// Stake stakes the selected wallet UTXOs and turns the node into a validator
	//
	// **Requires wallet to be unlocked**
	Stake(ctx context.Context, in *StakeRequest, opts ...grpc.CallOption) (*StakeResponse, error)
	// SetAutoStakeRewards make it such that any validator rewards that are earned are automatically staked
	//
	// **Requires wallet to be unlocked**
	SetAutoStakeRewards(ctx context.Context, in *SetAutoStakeRewardsRequest, opts ...grpc.CallOption) (*SetAutoStakeRewardsResponse, error)
	// Spend sends coins from the wallet according to the provided parameters
	//
	// **Requires wallet to be unlocked**
	Spend(ctx context.Context, in *SpendRequest, opts ...grpc.CallOption) (*SpendResponse, error)
	// TimelockCoins moves coins into a timelocked address using the requested timelock.
	// The internal wallet will be able to spend the coins after the timelock expires and
	// the transaction will be recoverable if the wallet is restored from seed.
	//
	// This RPC primarily exists to lock coins for staking purposes.
	//
	// **Requires wallet to be unlocked**
	TimelockCoins(ctx context.Context, in *TimelockCoinsRequest, opts ...grpc.CallOption) (*TimelockCoinsResponse, error)
	// SweepWallet sweeps all the coins from this wallet to the provided address.
	// This RPC is provided so that you don't have to try to guess the correct fee
	// to take the wallet's balance down to zero. Here the fee will be subtracted
	// from the total funds.
	//
	// **Requires wallet to be unlocked**
	SweepWallet(ctx context.Context, in *SweepWalletRequest, opts ...grpc.CallOption) (*SweepWalletResponse, error)
	// SubscribeWalletTransactions subscribes to a stream of WalletTransactionsNotifications that return
	// whenever a transaction belonging to the wallet finalizes.
	SubscribeWalletTransactions(ctx context.Context, in *SubscribeWalletTransactionsRequest, opts ...grpc.CallOption) (WalletService_SubscribeWalletTransactionsClient, error)
	// SubscribeWalletSyncNotifications streams notifications about the status of the wallet sync.
	SubscribeWalletSyncNotifications(ctx context.Context, in *SubscribeWalletSyncNotificationsRequest, opts ...grpc.CallOption) (WalletService_SubscribeWalletSyncNotificationsClient, error)
}

type walletServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWalletServiceClient(cc grpc.ClientConnInterface) WalletServiceClient {
	return &walletServiceClient{cc}
}

func (c *walletServiceClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetWalletSeed(ctx context.Context, in *GetWalletSeedRequest, opts ...grpc.CallOption) (*GetWalletSeedResponse, error) {
	out := new(GetWalletSeedResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetWalletSeed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetAddress(ctx context.Context, in *GetAddressRequest, opts ...grpc.CallOption) (*GetAddressResponse, error) {
	out := new(GetAddressResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetTimelockedAddress(ctx context.Context, in *GetTimelockedAddressRequest, opts ...grpc.CallOption) (*GetTimelockedAddressResponse, error) {
	out := new(GetTimelockedAddressResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetTimelockedAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetPublicAddress(ctx context.Context, in *GetPublicAddressRequest, opts ...grpc.CallOption) (*GetPublicAddressResponse, error) {
	out := new(GetPublicAddressResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetPublicAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetAddresses(ctx context.Context, in *GetAddressesRequest, opts ...grpc.CallOption) (*GetAddressesResponse, error) {
	out := new(GetAddressesResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetAddresses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetAddressInfo(ctx context.Context, in *GetAddressInfoRequest, opts ...grpc.CallOption) (*GetAddressInfoResponse, error) {
	out := new(GetAddressInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetAddressInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetNewAddress(ctx context.Context, in *GetNewAddressRequest, opts ...grpc.CallOption) (*GetNewAddressResponse, error) {
	out := new(GetNewAddressResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetNewAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (*GetTransactionsResponse, error) {
	out := new(GetTransactionsResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetUtxos(ctx context.Context, in *GetUtxosRequest, opts ...grpc.CallOption) (*GetUtxosResponse, error) {
	out := new(GetUtxosResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) GetPrivateKey(ctx context.Context, in *GetPrivateKeyRequest, opts ...grpc.CallOption) (*GetPrivateKeyResponse, error) {
	out := new(GetPrivateKeyResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/GetPrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) ImportAddress(ctx context.Context, in *ImportAddressRequest, opts ...grpc.CallOption) (*ImportAddressResponse, error) {
	out := new(ImportAddressResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/ImportAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) CreateMultisigSpendKeypair(ctx context.Context, in *CreateMultisigSpendKeypairRequest, opts ...grpc.CallOption) (*CreateMultisigSpendKeypairResponse, error) {
	out := new(CreateMultisigSpendKeypairResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/CreateMultisigSpendKeypair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) CreateMultisigViewKeypair(ctx context.Context, in *CreateMultisigViewKeypairRequest, opts ...grpc.CallOption) (*CreateMultisigViewKeypairResponse, error) {
	out := new(CreateMultisigViewKeypairResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/CreateMultisigViewKeypair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) CreateMultisigAddress(ctx context.Context, in *CreateMultisigAddressRequest, opts ...grpc.CallOption) (*CreateMultisigAddressResponse, error) {
	out := new(CreateMultisigAddressResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/CreateMultisigAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) CreateMultiSignature(ctx context.Context, in *CreateMultiSignatureRequest, opts ...grpc.CallOption) (*CreateMultiSignatureResponse, error) {
	out := new(CreateMultiSignatureResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/CreateMultiSignature", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) ProveMultisig(ctx context.Context, in *ProveMultisigRequest, opts ...grpc.CallOption) (*ProveMultisigResponse, error) {
	out := new(ProveMultisigResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/ProveMultisig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) WalletLock(ctx context.Context, in *WalletLockRequest, opts ...grpc.CallOption) (*WalletLockResponse, error) {
	out := new(WalletLockResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/WalletLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) WalletUnlock(ctx context.Context, in *WalletUnlockRequest, opts ...grpc.CallOption) (*WalletUnlockResponse, error) {
	out := new(WalletUnlockResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/WalletUnlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) SetWalletPassphrase(ctx context.Context, in *SetWalletPassphraseRequest, opts ...grpc.CallOption) (*SetWalletPassphraseResponse, error) {
	out := new(SetWalletPassphraseResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/SetWalletPassphrase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) ChangeWalletPassphrase(ctx context.Context, in *ChangeWalletPassphraseRequest, opts ...grpc.CallOption) (*ChangeWalletPassphraseResponse, error) {
	out := new(ChangeWalletPassphraseResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/ChangeWalletPassphrase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) DeletePrivateKeys(ctx context.Context, in *DeletePrivateKeysRequest, opts ...grpc.CallOption) (*DeletePrivateKeysResponse, error) {
	out := new(DeletePrivateKeysResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/DeletePrivateKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) CreateRawTransaction(ctx context.Context, in *CreateRawTransactionRequest, opts ...grpc.CallOption) (*CreateRawTransactionResponse, error) {
	out := new(CreateRawTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/CreateRawTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) CreateRawStakeTransaction(ctx context.Context, in *CreateRawStakeTransactionRequest, opts ...grpc.CallOption) (*CreateRawStakeTransactionResponse, error) {
	out := new(CreateRawStakeTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/CreateRawStakeTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) ProveRawTransaction(ctx context.Context, in *ProveRawTransactionRequest, opts ...grpc.CallOption) (*ProveRawTransactionResponse, error) {
	out := new(ProveRawTransactionResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/ProveRawTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) Stake(ctx context.Context, in *StakeRequest, opts ...grpc.CallOption) (*StakeResponse, error) {
	out := new(StakeResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/Stake", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) SetAutoStakeRewards(ctx context.Context, in *SetAutoStakeRewardsRequest, opts ...grpc.CallOption) (*SetAutoStakeRewardsResponse, error) {
	out := new(SetAutoStakeRewardsResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/SetAutoStakeRewards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) Spend(ctx context.Context, in *SpendRequest, opts ...grpc.CallOption) (*SpendResponse, error) {
	out := new(SpendResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/Spend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) TimelockCoins(ctx context.Context, in *TimelockCoinsRequest, opts ...grpc.CallOption) (*TimelockCoinsResponse, error) {
	out := new(TimelockCoinsResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/TimelockCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) SweepWallet(ctx context.Context, in *SweepWalletRequest, opts ...grpc.CallOption) (*SweepWalletResponse, error) {
	out := new(SweepWalletResponse)
	err := c.cc.Invoke(ctx, "/pb.WalletService/SweepWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletServiceClient) SubscribeWalletTransactions(ctx context.Context, in *SubscribeWalletTransactionsRequest, opts ...grpc.CallOption) (WalletService_SubscribeWalletTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &WalletService_ServiceDesc.Streams[0], "/pb.WalletService/SubscribeWalletTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &walletServiceSubscribeWalletTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WalletService_SubscribeWalletTransactionsClient interface {
	Recv() (*WalletTransactionNotification, error)
	grpc.ClientStream
}

type walletServiceSubscribeWalletTransactionsClient struct {
	grpc.ClientStream
}

func (x *walletServiceSubscribeWalletTransactionsClient) Recv() (*WalletTransactionNotification, error) {
	m := new(WalletTransactionNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *walletServiceClient) SubscribeWalletSyncNotifications(ctx context.Context, in *SubscribeWalletSyncNotificationsRequest, opts ...grpc.CallOption) (WalletService_SubscribeWalletSyncNotificationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &WalletService_ServiceDesc.Streams[1], "/pb.WalletService/SubscribeWalletSyncNotifications", opts...)
	if err != nil {
		return nil, err
	}
	x := &walletServiceSubscribeWalletSyncNotificationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WalletService_SubscribeWalletSyncNotificationsClient interface {
	Recv() (*WalletSyncNotification, error)
	grpc.ClientStream
}

type walletServiceSubscribeWalletSyncNotificationsClient struct {
	grpc.ClientStream
}

func (x *walletServiceSubscribeWalletSyncNotificationsClient) Recv() (*WalletSyncNotification, error) {
	m := new(WalletSyncNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// WalletServiceServer is the server API for WalletService service.
// All implementations must embed UnimplementedWalletServiceServer
// for forward compatibility
type WalletServiceServer interface {
	// GetBalance returns the combined balance of all addresses in the wallet
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	// GetWalletSeed returns the mnemonic seed for the wallet. If the wallet
	// seed has been deleted via the `DeletePrivateKeys` RPC an error will be
	// returned.
	//
	// **Requires wallet to be unlocked**
	GetWalletSeed(context.Context, *GetWalletSeedRequest) (*GetWalletSeedResponse, error)
	// GetAddress returns the most recent address of the wallet.
	GetAddress(context.Context, *GetAddressRequest) (*GetAddressResponse, error)
	// GetTimelockedAddress returns a timelocked address that cannot be spent
	// from until the given timelock has passed.
	//
	// The private key used for this address is the same as the wallet's most
	// recent spend key used in a basic address. This implies the key can be
	// derived from seed, however the wallet will not detect incoming payments
	// to this address unless the timelock is included in the utxo's state field.
	GetTimelockedAddress(context.Context, *GetTimelockedAddressRequest) (*GetTimelockedAddressResponse, error)
	// GetPublicAddress returns a public address for the wallet. This address type
	// requires that the private output data that is normally encrypted with the
	// recipient's view key be put in the transaction in the clear.
	//
	// The private key used for this address is the same as the wallet's most
	// recent spend key used in a basic address. This implies the key can be
	// derived from seed.
	GetPublicAddress(context.Context, *GetPublicAddressRequest) (*GetPublicAddressResponse, error)
	// GetAddresses returns all the addresses create by the wallet.
	GetAddresses(context.Context, *GetAddressesRequest) (*GetAddressesResponse, error)
	// GetAddressInfo returns additional metadata about an address.
	GetAddressInfo(context.Context, *GetAddressInfoRequest) (*GetAddressInfoResponse, error)
	// GetNewAddress generates a new address and returns it. Both a new spend key
	// and view key will be derived from the mnemonic seed.
	GetNewAddress(context.Context, *GetNewAddressRequest) (*GetNewAddressResponse, error)
	// GetTransactions returns the list of transactions for the wallet
	GetTransactions(context.Context, *GetTransactionsRequest) (*GetTransactionsResponse, error)
	// GetUtxos returns a list of the wallet's current unspent transaction outputs (UTXOs)
	GetUtxos(context.Context, *GetUtxosRequest) (*GetUtxosResponse, error)
	// GetPrivateKey returns the serialized spend and view keys for the given address
	//
	// **Requires wallet to be unlocked**
	GetPrivateKey(context.Context, *GetPrivateKeyRequest) (*GetPrivateKeyResponse, error)
	// ImportAddress imports a watch address into the wallet.
	ImportAddress(context.Context, *ImportAddressRequest) (*ImportAddressResponse, error)
	// CreateMultisigSpendKeypair generates a spend keypair for use in a multisig address
	CreateMultisigSpendKeypair(context.Context, *CreateMultisigSpendKeypairRequest) (*CreateMultisigSpendKeypairResponse, error)
	// CreateMultisigViewKeypair generates a view keypair for use in a multisig address
	CreateMultisigViewKeypair(context.Context, *CreateMultisigViewKeypairRequest) (*CreateMultisigViewKeypairResponse, error)
	// CreateMultisigAddress generates a new multisig address using the provided public keys
	//
	// Note this address is *not* imported. You will need to call `ImportAddress` if you want to watch
	// it.
	CreateMultisigAddress(context.Context, *CreateMultisigAddressRequest) (*CreateMultisigAddressResponse, error)
	// CreateMultiSignature generates and returns a signature for use when proving a multisig transaction
	CreateMultiSignature(context.Context, *CreateMultiSignatureRequest) (*CreateMultiSignatureResponse, error)
	// ProveMultisig creates a proof for a transaction with a multisig input
	ProveMultisig(context.Context, *ProveMultisigRequest) (*ProveMultisigResponse, error)
	// WalletLock encrypts the wallet's private keys
	WalletLock(context.Context, *WalletLockRequest) (*WalletLockResponse, error)
	// WalletUnlock decrypts the wallet seed and holds it in memory for the specified period of time
	WalletUnlock(context.Context, *WalletUnlockRequest) (*WalletUnlockResponse, error)
	// SetWalletPassphrase encrypts the wallet for the first time
	SetWalletPassphrase(context.Context, *SetWalletPassphraseRequest) (*SetWalletPassphraseResponse, error)
	// ChangeWalletPassphrase changes the passphrase used to encrypt the wallet private keys
	ChangeWalletPassphrase(context.Context, *ChangeWalletPassphraseRequest) (*ChangeWalletPassphraseResponse, error)
	// DeletePrivateKeys deletes the wallet's private keys and seed from disk essentially turning the wallet
	// into a watch-only wallet. It will still record incoming transactions but cannot spend them.
	//
	// **Requires wallet to be unlocked**
	DeletePrivateKeys(context.Context, *DeletePrivateKeysRequest) (*DeletePrivateKeysResponse, error)
	// CreateRawTransaction creates a new, unsigned (unproven) transaction using the given parameters
	CreateRawTransaction(context.Context, *CreateRawTransactionRequest) (*CreateRawTransactionResponse, error)
	// CreateRawStakeTransaction creates a new, unsigned (unproven) stake transaction using the given parameters
	CreateRawStakeTransaction(context.Context, *CreateRawStakeTransactionRequest) (*CreateRawStakeTransactionResponse, error)
	// ProveRawTransaction creates the zk-proof for the transaction. Assuming there are no errors, this
	// transaction should be ready for broadcast.
	ProveRawTransaction(context.Context, *ProveRawTransactionRequest) (*ProveRawTransactionResponse, error)
	// Stake stakes the selected wallet UTXOs and turns the node into a validator
	//
	// **Requires wallet to be unlocked**
	Stake(context.Context, *StakeRequest) (*StakeResponse, error)
	// SetAutoStakeRewards make it such that any validator rewards that are earned are automatically staked
	//
	// **Requires wallet to be unlocked**
	SetAutoStakeRewards(context.Context, *SetAutoStakeRewardsRequest) (*SetAutoStakeRewardsResponse, error)
	// Spend sends coins from the wallet according to the provided parameters
	//
	// **Requires wallet to be unlocked**
	Spend(context.Context, *SpendRequest) (*SpendResponse, error)
	// TimelockCoins moves coins into a timelocked address using the requested timelock.
	// The internal wallet will be able to spend the coins after the timelock expires and
	// the transaction will be recoverable if the wallet is restored from seed.
	//
	// This RPC primarily exists to lock coins for staking purposes.
	//
	// **Requires wallet to be unlocked**
	TimelockCoins(context.Context, *TimelockCoinsRequest) (*TimelockCoinsResponse, error)
	// SweepWallet sweeps all the coins from this wallet to the provided address.
	// This RPC is provided so that you don't have to try to guess the correct fee
	// to take the wallet's balance down to zero. Here the fee will be subtracted
	// from the total funds.
	//
	// **Requires wallet to be unlocked**
	SweepWallet(context.Context, *SweepWalletRequest) (*SweepWalletResponse, error)
	// SubscribeWalletTransactions subscribes to a stream of WalletTransactionsNotifications that return
	// whenever a transaction belonging to the wallet finalizes.
	SubscribeWalletTransactions(*SubscribeWalletTransactionsRequest, WalletService_SubscribeWalletTransactionsServer) error
	// SubscribeWalletSyncNotifications streams notifications about the status of the wallet sync.
	SubscribeWalletSyncNotifications(*SubscribeWalletSyncNotificationsRequest, WalletService_SubscribeWalletSyncNotificationsServer) error
	mustEmbedUnimplementedWalletServiceServer()
}

// UnimplementedWalletServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWalletServiceServer struct {
}

func (UnimplementedWalletServiceServer) GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedWalletServiceServer) GetWalletSeed(context.Context, *GetWalletSeedRequest) (*GetWalletSeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWalletSeed not implemented")
}
func (UnimplementedWalletServiceServer) GetAddress(context.Context, *GetAddressRequest) (*GetAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddress not implemented")
}
func (UnimplementedWalletServiceServer) GetTimelockedAddress(context.Context, *GetTimelockedAddressRequest) (*GetTimelockedAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimelockedAddress not implemented")
}
func (UnimplementedWalletServiceServer) GetPublicAddress(context.Context, *GetPublicAddressRequest) (*GetPublicAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPublicAddress not implemented")
}
func (UnimplementedWalletServiceServer) GetAddresses(context.Context, *GetAddressesRequest) (*GetAddressesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddresses not implemented")
}
func (UnimplementedWalletServiceServer) GetAddressInfo(context.Context, *GetAddressInfoRequest) (*GetAddressInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddressInfo not implemented")
}
func (UnimplementedWalletServiceServer) GetNewAddress(context.Context, *GetNewAddressRequest) (*GetNewAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNewAddress not implemented")
}
func (UnimplementedWalletServiceServer) GetTransactions(context.Context, *GetTransactionsRequest) (*GetTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactions not implemented")
}
func (UnimplementedWalletServiceServer) GetUtxos(context.Context, *GetUtxosRequest) (*GetUtxosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUtxos not implemented")
}
func (UnimplementedWalletServiceServer) GetPrivateKey(context.Context, *GetPrivateKeyRequest) (*GetPrivateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrivateKey not implemented")
}
func (UnimplementedWalletServiceServer) ImportAddress(context.Context, *ImportAddressRequest) (*ImportAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportAddress not implemented")
}
func (UnimplementedWalletServiceServer) CreateMultisigSpendKeypair(context.Context, *CreateMultisigSpendKeypairRequest) (*CreateMultisigSpendKeypairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultisigSpendKeypair not implemented")
}
func (UnimplementedWalletServiceServer) CreateMultisigViewKeypair(context.Context, *CreateMultisigViewKeypairRequest) (*CreateMultisigViewKeypairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultisigViewKeypair not implemented")
}
func (UnimplementedWalletServiceServer) CreateMultisigAddress(context.Context, *CreateMultisigAddressRequest) (*CreateMultisigAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultisigAddress not implemented")
}
func (UnimplementedWalletServiceServer) CreateMultiSignature(context.Context, *CreateMultiSignatureRequest) (*CreateMultiSignatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultiSignature not implemented")
}
func (UnimplementedWalletServiceServer) ProveMultisig(context.Context, *ProveMultisigRequest) (*ProveMultisigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProveMultisig not implemented")
}
func (UnimplementedWalletServiceServer) WalletLock(context.Context, *WalletLockRequest) (*WalletLockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletLock not implemented")
}
func (UnimplementedWalletServiceServer) WalletUnlock(context.Context, *WalletUnlockRequest) (*WalletUnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletUnlock not implemented")
}
func (UnimplementedWalletServiceServer) SetWalletPassphrase(context.Context, *SetWalletPassphraseRequest) (*SetWalletPassphraseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetWalletPassphrase not implemented")
}
func (UnimplementedWalletServiceServer) ChangeWalletPassphrase(context.Context, *ChangeWalletPassphraseRequest) (*ChangeWalletPassphraseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeWalletPassphrase not implemented")
}
func (UnimplementedWalletServiceServer) DeletePrivateKeys(context.Context, *DeletePrivateKeysRequest) (*DeletePrivateKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePrivateKeys not implemented")
}
func (UnimplementedWalletServiceServer) CreateRawTransaction(context.Context, *CreateRawTransactionRequest) (*CreateRawTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRawTransaction not implemented")
}
func (UnimplementedWalletServiceServer) CreateRawStakeTransaction(context.Context, *CreateRawStakeTransactionRequest) (*CreateRawStakeTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRawStakeTransaction not implemented")
}
func (UnimplementedWalletServiceServer) ProveRawTransaction(context.Context, *ProveRawTransactionRequest) (*ProveRawTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProveRawTransaction not implemented")
}
func (UnimplementedWalletServiceServer) Stake(context.Context, *StakeRequest) (*StakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stake not implemented")
}
func (UnimplementedWalletServiceServer) SetAutoStakeRewards(context.Context, *SetAutoStakeRewardsRequest) (*SetAutoStakeRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAutoStakeRewards not implemented")
}
func (UnimplementedWalletServiceServer) Spend(context.Context, *SpendRequest) (*SpendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Spend not implemented")
}
func (UnimplementedWalletServiceServer) TimelockCoins(context.Context, *TimelockCoinsRequest) (*TimelockCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TimelockCoins not implemented")
}
func (UnimplementedWalletServiceServer) SweepWallet(context.Context, *SweepWalletRequest) (*SweepWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SweepWallet not implemented")
}
func (UnimplementedWalletServiceServer) SubscribeWalletTransactions(*SubscribeWalletTransactionsRequest, WalletService_SubscribeWalletTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeWalletTransactions not implemented")
}
func (UnimplementedWalletServiceServer) SubscribeWalletSyncNotifications(*SubscribeWalletSyncNotificationsRequest, WalletService_SubscribeWalletSyncNotificationsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeWalletSyncNotifications not implemented")
}
func (UnimplementedWalletServiceServer) mustEmbedUnimplementedWalletServiceServer() {}

// UnsafeWalletServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WalletServiceServer will
// result in compilation errors.
type UnsafeWalletServiceServer interface {
	mustEmbedUnimplementedWalletServiceServer()
}

func RegisterWalletServiceServer(s grpc.ServiceRegistrar, srv WalletServiceServer) {
	s.RegisterService(&WalletService_ServiceDesc, srv)
}

func _WalletService_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetWalletSeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWalletSeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetWalletSeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetWalletSeed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetWalletSeed(ctx, req.(*GetWalletSeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetAddress(ctx, req.(*GetAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetTimelockedAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimelockedAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetTimelockedAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetTimelockedAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetTimelockedAddress(ctx, req.(*GetTimelockedAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetPublicAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetPublicAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetPublicAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetPublicAddress(ctx, req.(*GetPublicAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetAddresses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetAddresses(ctx, req.(*GetAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetAddressInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetAddressInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetAddressInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetAddressInfo(ctx, req.(*GetAddressInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetNewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNewAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetNewAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetNewAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetNewAddress(ctx, req.(*GetNewAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetTransactions(ctx, req.(*GetTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetUtxos(ctx, req.(*GetUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_GetPrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).GetPrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/GetPrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).GetPrivateKey(ctx, req.(*GetPrivateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_ImportAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).ImportAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/ImportAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).ImportAddress(ctx, req.(*ImportAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_CreateMultisigSpendKeypair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMultisigSpendKeypairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).CreateMultisigSpendKeypair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/CreateMultisigSpendKeypair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).CreateMultisigSpendKeypair(ctx, req.(*CreateMultisigSpendKeypairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_CreateMultisigViewKeypair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMultisigViewKeypairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).CreateMultisigViewKeypair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/CreateMultisigViewKeypair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).CreateMultisigViewKeypair(ctx, req.(*CreateMultisigViewKeypairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_CreateMultisigAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMultisigAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).CreateMultisigAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/CreateMultisigAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).CreateMultisigAddress(ctx, req.(*CreateMultisigAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_CreateMultiSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMultiSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).CreateMultiSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/CreateMultiSignature",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).CreateMultiSignature(ctx, req.(*CreateMultiSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_ProveMultisig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProveMultisigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).ProveMultisig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/ProveMultisig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).ProveMultisig(ctx, req.(*ProveMultisigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_WalletLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).WalletLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/WalletLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).WalletLock(ctx, req.(*WalletLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_WalletUnlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletUnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).WalletUnlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/WalletUnlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).WalletUnlock(ctx, req.(*WalletUnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_SetWalletPassphrase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetWalletPassphraseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).SetWalletPassphrase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/SetWalletPassphrase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).SetWalletPassphrase(ctx, req.(*SetWalletPassphraseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_ChangeWalletPassphrase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeWalletPassphraseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).ChangeWalletPassphrase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/ChangeWalletPassphrase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).ChangeWalletPassphrase(ctx, req.(*ChangeWalletPassphraseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_DeletePrivateKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePrivateKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).DeletePrivateKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/DeletePrivateKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).DeletePrivateKeys(ctx, req.(*DeletePrivateKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_CreateRawTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRawTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).CreateRawTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/CreateRawTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).CreateRawTransaction(ctx, req.(*CreateRawTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_CreateRawStakeTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRawStakeTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).CreateRawStakeTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/CreateRawStakeTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).CreateRawStakeTransaction(ctx, req.(*CreateRawStakeTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_ProveRawTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProveRawTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).ProveRawTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/ProveRawTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).ProveRawTransaction(ctx, req.(*ProveRawTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_Stake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).Stake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/Stake",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).Stake(ctx, req.(*StakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_SetAutoStakeRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAutoStakeRewardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).SetAutoStakeRewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/SetAutoStakeRewards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).SetAutoStakeRewards(ctx, req.(*SetAutoStakeRewardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_Spend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).Spend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/Spend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).Spend(ctx, req.(*SpendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_TimelockCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimelockCoinsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).TimelockCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/TimelockCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).TimelockCoins(ctx, req.(*TimelockCoinsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_SweepWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SweepWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServiceServer).SweepWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.WalletService/SweepWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServiceServer).SweepWallet(ctx, req.(*SweepWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WalletService_SubscribeWalletTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeWalletTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WalletServiceServer).SubscribeWalletTransactions(m, &walletServiceSubscribeWalletTransactionsServer{stream})
}

type WalletService_SubscribeWalletTransactionsServer interface {
	Send(*WalletTransactionNotification) error
	grpc.ServerStream
}

type walletServiceSubscribeWalletTransactionsServer struct {
	grpc.ServerStream
}

func (x *walletServiceSubscribeWalletTransactionsServer) Send(m *WalletTransactionNotification) error {
	return x.ServerStream.SendMsg(m)
}

func _WalletService_SubscribeWalletSyncNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeWalletSyncNotificationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WalletServiceServer).SubscribeWalletSyncNotifications(m, &walletServiceSubscribeWalletSyncNotificationsServer{stream})
}

type WalletService_SubscribeWalletSyncNotificationsServer interface {
	Send(*WalletSyncNotification) error
	grpc.ServerStream
}

type walletServiceSubscribeWalletSyncNotificationsServer struct {
	grpc.ServerStream
}

func (x *walletServiceSubscribeWalletSyncNotificationsServer) Send(m *WalletSyncNotification) error {
	return x.ServerStream.SendMsg(m)
}

// WalletService_ServiceDesc is the grpc.ServiceDesc for WalletService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WalletService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.WalletService",
	HandlerType: (*WalletServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBalance",
			Handler:    _WalletService_GetBalance_Handler,
		},
		{
			MethodName: "GetWalletSeed",
			Handler:    _WalletService_GetWalletSeed_Handler,
		},
		{
			MethodName: "GetAddress",
			Handler:    _WalletService_GetAddress_Handler,
		},
		{
			MethodName: "GetTimelockedAddress",
			Handler:    _WalletService_GetTimelockedAddress_Handler,
		},
		{
			MethodName: "GetPublicAddress",
			Handler:    _WalletService_GetPublicAddress_Handler,
		},
		{
			MethodName: "GetAddresses",
			Handler:    _WalletService_GetAddresses_Handler,
		},
		{
			MethodName: "GetAddressInfo",
			Handler:    _WalletService_GetAddressInfo_Handler,
		},
		{
			MethodName: "GetNewAddress",
			Handler:    _WalletService_GetNewAddress_Handler,
		},
		{
			MethodName: "GetTransactions",
			Handler:    _WalletService_GetTransactions_Handler,
		},
		{
			MethodName: "GetUtxos",
			Handler:    _WalletService_GetUtxos_Handler,
		},
		{
			MethodName: "GetPrivateKey",
			Handler:    _WalletService_GetPrivateKey_Handler,
		},
		{
			MethodName: "ImportAddress",
			Handler:    _WalletService_ImportAddress_Handler,
		},
		{
			MethodName: "CreateMultisigSpendKeypair",
			Handler:    _WalletService_CreateMultisigSpendKeypair_Handler,
		},
		{
			MethodName: "CreateMultisigViewKeypair",
			Handler:    _WalletService_CreateMultisigViewKeypair_Handler,
		},
		{
			MethodName: "CreateMultisigAddress",
			Handler:    _WalletService_CreateMultisigAddress_Handler,
		},
		{
			MethodName: "CreateMultiSignature",
			Handler:    _WalletService_CreateMultiSignature_Handler,
		},
		{
			MethodName: "ProveMultisig",
			Handler:    _WalletService_ProveMultisig_Handler,
		},
		{
			MethodName: "WalletLock",
			Handler:    _WalletService_WalletLock_Handler,
		},
		{
			MethodName: "WalletUnlock",
			Handler:    _WalletService_WalletUnlock_Handler,
		},
		{
			MethodName: "SetWalletPassphrase",
			Handler:    _WalletService_SetWalletPassphrase_Handler,
		},
		{
			MethodName: "ChangeWalletPassphrase",
			Handler:    _WalletService_ChangeWalletPassphrase_Handler,
		},
		{
			MethodName: "DeletePrivateKeys",
			Handler:    _WalletService_DeletePrivateKeys_Handler,
		},
		{
			MethodName: "CreateRawTransaction",
			Handler:    _WalletService_CreateRawTransaction_Handler,
		},
		{
			MethodName: "CreateRawStakeTransaction",
			Handler:    _WalletService_CreateRawStakeTransaction_Handler,
		},
		{
			MethodName: "ProveRawTransaction",
			Handler:    _WalletService_ProveRawTransaction_Handler,
		},
		{
			MethodName: "Stake",
			Handler:    _WalletService_Stake_Handler,
		},
		{
			MethodName: "SetAutoStakeRewards",
			Handler:    _WalletService_SetAutoStakeRewards_Handler,
		},
		{
			MethodName: "Spend",
			Handler:    _WalletService_Spend_Handler,
		},
		{
			MethodName: "TimelockCoins",
			Handler:    _WalletService_TimelockCoins_Handler,
		},
		{
			MethodName: "SweepWallet",
			Handler:    _WalletService_SweepWallet_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeWalletTransactions",
			Handler:       _WalletService_SubscribeWalletTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeWalletSyncNotifications",
			Handler:       _WalletService_SubscribeWalletSyncNotifications_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ilxrpc.proto",
}

// NodeServiceClient is the client API for NodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeServiceClient interface {
	// GetHostInfo returns info about the libp2p host
	GetHostInfo(ctx context.Context, in *GetHostInfoRequest, opts ...grpc.CallOption) (*GetHostInfoResponse, error)
	// GetNetworkKey returns the node's network private key
	GetNetworkKey(ctx context.Context, in *GetNetworkKeyRequest, opts ...grpc.CallOption) (*GetNetworkKeyResponse, error)
	// GetPeers returns a list of peers that this node is connected to
	GetPeers(ctx context.Context, in *GetPeersRequest, opts ...grpc.CallOption) (*GetPeersResponse, error)
	// GetPeerInfo returns a list of peers that this node is connected to
	GetPeerInfo(ctx context.Context, in *GetPeerInfoRequest, opts ...grpc.CallOption) (*GetPeerInfoResponse, error)
	// AddPeer attempts to connect to the provided peer
	AddPeer(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*AddPeerResponse, error)
	// BlockPeer blocks the given peer for the provided time period
	BlockPeer(ctx context.Context, in *BlockPeerRequest, opts ...grpc.CallOption) (*BlockPeerResponse, error)
	// UnblockPeer removes a peer from the block list
	UnblockPeer(ctx context.Context, in *UnblockPeerRequest, opts ...grpc.CallOption) (*UnblockPeerResponse, error)
	// SetLogLevel changes the logging level of the node
	SetLogLevel(ctx context.Context, in *SetLogLevelRequest, opts ...grpc.CallOption) (*SetLogLevelResponse, error)
	// GetMinFeePerKilobyte returns the node's current minimum transaction fee needed to relay
	// transactions and admit them into the mempool. Validators will also set their initial preference
	// for blocks containing transactions with fees below this threshold to not-preferred.
	GetMinFeePerKilobyte(ctx context.Context, in *GetMinFeePerKilobyteRequest, opts ...grpc.CallOption) (*GetMinFeePerKilobyteResponse, error)
	// SetMinFeePerKilobyte sets the node's fee policy
	SetMinFeePerKilobyte(ctx context.Context, in *SetMinFeePerKilobyteRequest, opts ...grpc.CallOption) (*SetMinFeePerKilobyteResponse, error)
	// GetMinStake returns the node's current minimum stake policy. Stake transactions staking less than
	// this amount will not be admitted into the mempool and will not be relayed. Validators will also
	// set their initial preference for blocks containing stake transactions below this threshold to
	// not-preferred.
	GetMinStake(ctx context.Context, in *GetMinStakeRequest, opts ...grpc.CallOption) (*GetMinStakeResponse, error)
	// SetMinStake sets the node's minimum stake policy
	SetMinStake(ctx context.Context, in *SetMinStakeRequest, opts ...grpc.CallOption) (*SetMinStakeResponse, error)
	// GetBlockSizeSoftLimit returns the node's current blocksize soft limit. Validators will also
	// set their initial preference for blocks over this size to not-preferred.
	GetBlockSizeSoftLimit(ctx context.Context, in *GetBlockSizeSoftLimitRequest, opts ...grpc.CallOption) (*GetBlockSizeSoftLimitResponse, error)
	// SetBlockSizeSoftLimit sets the node's blocksize soft limit policy.
	SetBlockSizeSoftLimit(ctx context.Context, in *SetBlockSizeSoftLimitRequest, opts ...grpc.CallOption) (*SetBlockSizeSoftLimitResponse, error)
	// GetTreasuryWhitelist returns the current treasury whitelist for the node. Blocks containing
	// TreasuryTransactions not found in this list will have their initial preference set to not-preferred.
	GetTreasuryWhitelist(ctx context.Context, in *GetTreasuryWhitelistRequest, opts ...grpc.CallOption) (*GetTreasuryWhitelistResponse, error)
	// UpdateTreasuryWhitelist adds or removes a transaction to from the treasury whitelist.
	// This update is committed to the datastore and will persist between sessions.
	UpdateTreasuryWhitelist(ctx context.Context, in *UpdateTreasuryWhitelistRequest, opts ...grpc.CallOption) (*UpdateTreasuryWhitelistResponse, error)
	// ReconsiderBlock tries to reprocess the given block
	ReconsiderBlock(ctx context.Context, in *ReconsiderBlockRequest, opts ...grpc.CallOption) (*ReconsiderBlockResponse, error)
	// RecomputeChainState deletes the accumulator, validator set, and nullifier set and rebuilds them by
	// loading and re-processing all blocks from genesis.
	RecomputeChainState(ctx context.Context, in *RecomputeChainStateRequest, opts ...grpc.CallOption) (*RecomputeChainStateResponse, error)
}

type nodeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeServiceClient(cc grpc.ClientConnInterface) NodeServiceClient {
	return &nodeServiceClient{cc}
}

func (c *nodeServiceClient) GetHostInfo(ctx context.Context, in *GetHostInfoRequest, opts ...grpc.CallOption) (*GetHostInfoResponse, error) {
	out := new(GetHostInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/GetHostInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetNetworkKey(ctx context.Context, in *GetNetworkKeyRequest, opts ...grpc.CallOption) (*GetNetworkKeyResponse, error) {
	out := new(GetNetworkKeyResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/GetNetworkKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetPeers(ctx context.Context, in *GetPeersRequest, opts ...grpc.CallOption) (*GetPeersResponse, error) {
	out := new(GetPeersResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/GetPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetPeerInfo(ctx context.Context, in *GetPeerInfoRequest, opts ...grpc.CallOption) (*GetPeerInfoResponse, error) {
	out := new(GetPeerInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/GetPeerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) AddPeer(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*AddPeerResponse, error) {
	out := new(AddPeerResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/AddPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) BlockPeer(ctx context.Context, in *BlockPeerRequest, opts ...grpc.CallOption) (*BlockPeerResponse, error) {
	out := new(BlockPeerResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/BlockPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) UnblockPeer(ctx context.Context, in *UnblockPeerRequest, opts ...grpc.CallOption) (*UnblockPeerResponse, error) {
	out := new(UnblockPeerResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/UnblockPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) SetLogLevel(ctx context.Context, in *SetLogLevelRequest, opts ...grpc.CallOption) (*SetLogLevelResponse, error) {
	out := new(SetLogLevelResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/SetLogLevel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetMinFeePerKilobyte(ctx context.Context, in *GetMinFeePerKilobyteRequest, opts ...grpc.CallOption) (*GetMinFeePerKilobyteResponse, error) {
	out := new(GetMinFeePerKilobyteResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/GetMinFeePerKilobyte", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) SetMinFeePerKilobyte(ctx context.Context, in *SetMinFeePerKilobyteRequest, opts ...grpc.CallOption) (*SetMinFeePerKilobyteResponse, error) {
	out := new(SetMinFeePerKilobyteResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/SetMinFeePerKilobyte", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetMinStake(ctx context.Context, in *GetMinStakeRequest, opts ...grpc.CallOption) (*GetMinStakeResponse, error) {
	out := new(GetMinStakeResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/GetMinStake", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) SetMinStake(ctx context.Context, in *SetMinStakeRequest, opts ...grpc.CallOption) (*SetMinStakeResponse, error) {
	out := new(SetMinStakeResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/SetMinStake", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetBlockSizeSoftLimit(ctx context.Context, in *GetBlockSizeSoftLimitRequest, opts ...grpc.CallOption) (*GetBlockSizeSoftLimitResponse, error) {
	out := new(GetBlockSizeSoftLimitResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/GetBlockSizeSoftLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) SetBlockSizeSoftLimit(ctx context.Context, in *SetBlockSizeSoftLimitRequest, opts ...grpc.CallOption) (*SetBlockSizeSoftLimitResponse, error) {
	out := new(SetBlockSizeSoftLimitResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/SetBlockSizeSoftLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) GetTreasuryWhitelist(ctx context.Context, in *GetTreasuryWhitelistRequest, opts ...grpc.CallOption) (*GetTreasuryWhitelistResponse, error) {
	out := new(GetTreasuryWhitelistResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/GetTreasuryWhitelist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) UpdateTreasuryWhitelist(ctx context.Context, in *UpdateTreasuryWhitelistRequest, opts ...grpc.CallOption) (*UpdateTreasuryWhitelistResponse, error) {
	out := new(UpdateTreasuryWhitelistResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/UpdateTreasuryWhitelist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) ReconsiderBlock(ctx context.Context, in *ReconsiderBlockRequest, opts ...grpc.CallOption) (*ReconsiderBlockResponse, error) {
	out := new(ReconsiderBlockResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/ReconsiderBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) RecomputeChainState(ctx context.Context, in *RecomputeChainStateRequest, opts ...grpc.CallOption) (*RecomputeChainStateResponse, error) {
	out := new(RecomputeChainStateResponse)
	err := c.cc.Invoke(ctx, "/pb.NodeService/RecomputeChainState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServiceServer is the server API for NodeService service.
// All implementations must embed UnimplementedNodeServiceServer
// for forward compatibility
type NodeServiceServer interface {
	// GetHostInfo returns info about the libp2p host
	GetHostInfo(context.Context, *GetHostInfoRequest) (*GetHostInfoResponse, error)
	// GetNetworkKey returns the node's network private key
	GetNetworkKey(context.Context, *GetNetworkKeyRequest) (*GetNetworkKeyResponse, error)
	// GetPeers returns a list of peers that this node is connected to
	GetPeers(context.Context, *GetPeersRequest) (*GetPeersResponse, error)
	// GetPeerInfo returns a list of peers that this node is connected to
	GetPeerInfo(context.Context, *GetPeerInfoRequest) (*GetPeerInfoResponse, error)
	// AddPeer attempts to connect to the provided peer
	AddPeer(context.Context, *AddPeerRequest) (*AddPeerResponse, error)
	// BlockPeer blocks the given peer for the provided time period
	BlockPeer(context.Context, *BlockPeerRequest) (*BlockPeerResponse, error)
	// UnblockPeer removes a peer from the block list
	UnblockPeer(context.Context, *UnblockPeerRequest) (*UnblockPeerResponse, error)
	// SetLogLevel changes the logging level of the node
	SetLogLevel(context.Context, *SetLogLevelRequest) (*SetLogLevelResponse, error)
	// GetMinFeePerKilobyte returns the node's current minimum transaction fee needed to relay
	// transactions and admit them into the mempool. Validators will also set their initial preference
	// for blocks containing transactions with fees below this threshold to not-preferred.
	GetMinFeePerKilobyte(context.Context, *GetMinFeePerKilobyteRequest) (*GetMinFeePerKilobyteResponse, error)
	// SetMinFeePerKilobyte sets the node's fee policy
	SetMinFeePerKilobyte(context.Context, *SetMinFeePerKilobyteRequest) (*SetMinFeePerKilobyteResponse, error)
	// GetMinStake returns the node's current minimum stake policy. Stake transactions staking less than
	// this amount will not be admitted into the mempool and will not be relayed. Validators will also
	// set their initial preference for blocks containing stake transactions below this threshold to
	// not-preferred.
	GetMinStake(context.Context, *GetMinStakeRequest) (*GetMinStakeResponse, error)
	// SetMinStake sets the node's minimum stake policy
	SetMinStake(context.Context, *SetMinStakeRequest) (*SetMinStakeResponse, error)
	// GetBlockSizeSoftLimit returns the node's current blocksize soft limit. Validators will also
	// set their initial preference for blocks over this size to not-preferred.
	GetBlockSizeSoftLimit(context.Context, *GetBlockSizeSoftLimitRequest) (*GetBlockSizeSoftLimitResponse, error)
	// SetBlockSizeSoftLimit sets the node's blocksize soft limit policy.
	SetBlockSizeSoftLimit(context.Context, *SetBlockSizeSoftLimitRequest) (*SetBlockSizeSoftLimitResponse, error)
	// GetTreasuryWhitelist returns the current treasury whitelist for the node. Blocks containing
	// TreasuryTransactions not found in this list will have their initial preference set to not-preferred.
	GetTreasuryWhitelist(context.Context, *GetTreasuryWhitelistRequest) (*GetTreasuryWhitelistResponse, error)
	// UpdateTreasuryWhitelist adds or removes a transaction to from the treasury whitelist.
	// This update is committed to the datastore and will persist between sessions.
	UpdateTreasuryWhitelist(context.Context, *UpdateTreasuryWhitelistRequest) (*UpdateTreasuryWhitelistResponse, error)
	// ReconsiderBlock tries to reprocess the given block
	ReconsiderBlock(context.Context, *ReconsiderBlockRequest) (*ReconsiderBlockResponse, error)
	// RecomputeChainState deletes the accumulator, validator set, and nullifier set and rebuilds them by
	// loading and re-processing all blocks from genesis.
	RecomputeChainState(context.Context, *RecomputeChainStateRequest) (*RecomputeChainStateResponse, error)
	mustEmbedUnimplementedNodeServiceServer()
}

// UnimplementedNodeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNodeServiceServer struct {
}

func (UnimplementedNodeServiceServer) GetHostInfo(context.Context, *GetHostInfoRequest) (*GetHostInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHostInfo not implemented")
}
func (UnimplementedNodeServiceServer) GetNetworkKey(context.Context, *GetNetworkKeyRequest) (*GetNetworkKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkKey not implemented")
}
func (UnimplementedNodeServiceServer) GetPeers(context.Context, *GetPeersRequest) (*GetPeersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeers not implemented")
}
func (UnimplementedNodeServiceServer) GetPeerInfo(context.Context, *GetPeerInfoRequest) (*GetPeerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeerInfo not implemented")
}
func (UnimplementedNodeServiceServer) AddPeer(context.Context, *AddPeerRequest) (*AddPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPeer not implemented")
}
func (UnimplementedNodeServiceServer) BlockPeer(context.Context, *BlockPeerRequest) (*BlockPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockPeer not implemented")
}
func (UnimplementedNodeServiceServer) UnblockPeer(context.Context, *UnblockPeerRequest) (*UnblockPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnblockPeer not implemented")
}
func (UnimplementedNodeServiceServer) SetLogLevel(context.Context, *SetLogLevelRequest) (*SetLogLevelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLogLevel not implemented")
}
func (UnimplementedNodeServiceServer) GetMinFeePerKilobyte(context.Context, *GetMinFeePerKilobyteRequest) (*GetMinFeePerKilobyteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMinFeePerKilobyte not implemented")
}
func (UnimplementedNodeServiceServer) SetMinFeePerKilobyte(context.Context, *SetMinFeePerKilobyteRequest) (*SetMinFeePerKilobyteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinFeePerKilobyte not implemented")
}
func (UnimplementedNodeServiceServer) GetMinStake(context.Context, *GetMinStakeRequest) (*GetMinStakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMinStake not implemented")
}
func (UnimplementedNodeServiceServer) SetMinStake(context.Context, *SetMinStakeRequest) (*SetMinStakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinStake not implemented")
}
func (UnimplementedNodeServiceServer) GetBlockSizeSoftLimit(context.Context, *GetBlockSizeSoftLimitRequest) (*GetBlockSizeSoftLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockSizeSoftLimit not implemented")
}
func (UnimplementedNodeServiceServer) SetBlockSizeSoftLimit(context.Context, *SetBlockSizeSoftLimitRequest) (*SetBlockSizeSoftLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBlockSizeSoftLimit not implemented")
}
func (UnimplementedNodeServiceServer) GetTreasuryWhitelist(context.Context, *GetTreasuryWhitelistRequest) (*GetTreasuryWhitelistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTreasuryWhitelist not implemented")
}
func (UnimplementedNodeServiceServer) UpdateTreasuryWhitelist(context.Context, *UpdateTreasuryWhitelistRequest) (*UpdateTreasuryWhitelistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTreasuryWhitelist not implemented")
}
func (UnimplementedNodeServiceServer) ReconsiderBlock(context.Context, *ReconsiderBlockRequest) (*ReconsiderBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReconsiderBlock not implemented")
}
func (UnimplementedNodeServiceServer) RecomputeChainState(context.Context, *RecomputeChainStateRequest) (*RecomputeChainStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecomputeChainState not implemented")
}
func (UnimplementedNodeServiceServer) mustEmbedUnimplementedNodeServiceServer() {}

// UnsafeNodeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServiceServer will
// result in compilation errors.
type UnsafeNodeServiceServer interface {
	mustEmbedUnimplementedNodeServiceServer()
}

func RegisterNodeServiceServer(s grpc.ServiceRegistrar, srv NodeServiceServer) {
	s.RegisterService(&NodeService_ServiceDesc, srv)
}

func _NodeService_GetHostInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHostInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetHostInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/GetHostInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetHostInfo(ctx, req.(*GetHostInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetNetworkKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetNetworkKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/GetNetworkKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetNetworkKey(ctx, req.(*GetNetworkKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/GetPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetPeers(ctx, req.(*GetPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetPeerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetPeerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/GetPeerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetPeerInfo(ctx, req.(*GetPeerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_AddPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).AddPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/AddPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).AddPeer(ctx, req.(*AddPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_BlockPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).BlockPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/BlockPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).BlockPeer(ctx, req.(*BlockPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_UnblockPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnblockPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).UnblockPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/UnblockPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).UnblockPeer(ctx, req.(*UnblockPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_SetLogLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLogLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).SetLogLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/SetLogLevel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).SetLogLevel(ctx, req.(*SetLogLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetMinFeePerKilobyte_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMinFeePerKilobyteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetMinFeePerKilobyte(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/GetMinFeePerKilobyte",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetMinFeePerKilobyte(ctx, req.(*GetMinFeePerKilobyteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_SetMinFeePerKilobyte_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMinFeePerKilobyteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).SetMinFeePerKilobyte(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/SetMinFeePerKilobyte",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).SetMinFeePerKilobyte(ctx, req.(*SetMinFeePerKilobyteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetMinStake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMinStakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetMinStake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/GetMinStake",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetMinStake(ctx, req.(*GetMinStakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_SetMinStake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMinStakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).SetMinStake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/SetMinStake",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).SetMinStake(ctx, req.(*SetMinStakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetBlockSizeSoftLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockSizeSoftLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetBlockSizeSoftLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/GetBlockSizeSoftLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetBlockSizeSoftLimit(ctx, req.(*GetBlockSizeSoftLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_SetBlockSizeSoftLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBlockSizeSoftLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).SetBlockSizeSoftLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/SetBlockSizeSoftLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).SetBlockSizeSoftLimit(ctx, req.(*SetBlockSizeSoftLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_GetTreasuryWhitelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTreasuryWhitelistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).GetTreasuryWhitelist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/GetTreasuryWhitelist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).GetTreasuryWhitelist(ctx, req.(*GetTreasuryWhitelistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_UpdateTreasuryWhitelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTreasuryWhitelistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).UpdateTreasuryWhitelist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/UpdateTreasuryWhitelist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).UpdateTreasuryWhitelist(ctx, req.(*UpdateTreasuryWhitelistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_ReconsiderBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReconsiderBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).ReconsiderBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/ReconsiderBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).ReconsiderBlock(ctx, req.(*ReconsiderBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_RecomputeChainState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecomputeChainStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).RecomputeChainState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.NodeService/RecomputeChainState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).RecomputeChainState(ctx, req.(*RecomputeChainStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeService_ServiceDesc is the grpc.ServiceDesc for NodeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.NodeService",
	HandlerType: (*NodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHostInfo",
			Handler:    _NodeService_GetHostInfo_Handler,
		},
		{
			MethodName: "GetNetworkKey",
			Handler:    _NodeService_GetNetworkKey_Handler,
		},
		{
			MethodName: "GetPeers",
			Handler:    _NodeService_GetPeers_Handler,
		},
		{
			MethodName: "GetPeerInfo",
			Handler:    _NodeService_GetPeerInfo_Handler,
		},
		{
			MethodName: "AddPeer",
			Handler:    _NodeService_AddPeer_Handler,
		},
		{
			MethodName: "BlockPeer",
			Handler:    _NodeService_BlockPeer_Handler,
		},
		{
			MethodName: "UnblockPeer",
			Handler:    _NodeService_UnblockPeer_Handler,
		},
		{
			MethodName: "SetLogLevel",
			Handler:    _NodeService_SetLogLevel_Handler,
		},
		{
			MethodName: "GetMinFeePerKilobyte",
			Handler:    _NodeService_GetMinFeePerKilobyte_Handler,
		},
		{
			MethodName: "SetMinFeePerKilobyte",
			Handler:    _NodeService_SetMinFeePerKilobyte_Handler,
		},
		{
			MethodName: "GetMinStake",
			Handler:    _NodeService_GetMinStake_Handler,
		},
		{
			MethodName: "SetMinStake",
			Handler:    _NodeService_SetMinStake_Handler,
		},
		{
			MethodName: "GetBlockSizeSoftLimit",
			Handler:    _NodeService_GetBlockSizeSoftLimit_Handler,
		},
		{
			MethodName: "SetBlockSizeSoftLimit",
			Handler:    _NodeService_SetBlockSizeSoftLimit_Handler,
		},
		{
			MethodName: "GetTreasuryWhitelist",
			Handler:    _NodeService_GetTreasuryWhitelist_Handler,
		},
		{
			MethodName: "UpdateTreasuryWhitelist",
			Handler:    _NodeService_UpdateTreasuryWhitelist_Handler,
		},
		{
			MethodName: "ReconsiderBlock",
			Handler:    _NodeService_ReconsiderBlock_Handler,
		},
		{
			MethodName: "RecomputeChainState",
			Handler:    _NodeService_RecomputeChainState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ilxrpc.proto",
}
